// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal.proto

package protocol

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Op int32

const (
	Op_CREATE_STREAM                     Op = 0
	Op_SHRINK_ISR                        Op = 1
	Op_REPORT_LEADER                     Op = 2
	Op_CHANGE_LEADER                     Op = 3
	Op_EXPAND_ISR                        Op = 4
	Op_DELETE_STREAM                     Op = 5
	Op_PAUSE_STREAM                      Op = 6
	Op_RESUME_STREAM                     Op = 7
	Op_PUBLISH_ACTIVITY                  Op = 8
	Op_SET_STREAM_READONLY               Op = 9
	Op_CREATE_CONSUMER_GROUP             Op = 10
	Op_JOIN_CONSUMER_GROUP               Op = 11
	Op_LEAVE_CONSUMER_GROUP              Op = 12
	Op_REPORT_CONSUMER_GROUP_COORDINATOR Op = 13
	Op_CHANGE_CONSUMER_GROUP_COORDINATOR Op = 14
	Op_ADD_POLICY                        Op = 15
	Op_REVOKE_POLICY                     Op = 16
)

var Op_name = map[int32]string{
	0:  "CREATE_STREAM",
	1:  "SHRINK_ISR",
	2:  "REPORT_LEADER",
	3:  "CHANGE_LEADER",
	4:  "EXPAND_ISR",
	5:  "DELETE_STREAM",
	6:  "PAUSE_STREAM",
	7:  "RESUME_STREAM",
	8:  "PUBLISH_ACTIVITY",
	9:  "SET_STREAM_READONLY",
	10: "CREATE_CONSUMER_GROUP",
	11: "JOIN_CONSUMER_GROUP",
	12: "LEAVE_CONSUMER_GROUP",
	13: "REPORT_CONSUMER_GROUP_COORDINATOR",
	14: "CHANGE_CONSUMER_GROUP_COORDINATOR",
	15: "ADD_POLICY",
	16: "REVOKE_POLICY",
}

var Op_value = map[string]int32{
	"CREATE_STREAM":                     0,
	"SHRINK_ISR":                        1,
	"REPORT_LEADER":                     2,
	"CHANGE_LEADER":                     3,
	"EXPAND_ISR":                        4,
	"DELETE_STREAM":                     5,
	"PAUSE_STREAM":                      6,
	"RESUME_STREAM":                     7,
	"PUBLISH_ACTIVITY":                  8,
	"SET_STREAM_READONLY":               9,
	"CREATE_CONSUMER_GROUP":             10,
	"JOIN_CONSUMER_GROUP":               11,
	"LEAVE_CONSUMER_GROUP":              12,
	"REPORT_CONSUMER_GROUP_COORDINATOR": 13,
	"CHANGE_CONSUMER_GROUP_COORDINATOR": 14,
	"ADD_POLICY":                        15,
	"REVOKE_POLICY":                     16,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{0}
}

type ServerState struct {
	ServerID             string   `protobuf:"bytes,1,opt,name=serverID,proto3" json:"serverID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerState) Reset()         { *m = ServerState{} }
func (m *ServerState) String() string { return proto.CompactTextString(m) }
func (*ServerState) ProtoMessage()    {}
func (*ServerState) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{0}
}
func (m *ServerState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerState.Merge(m, src)
}
func (m *ServerState) XXX_Size() int {
	return m.Size()
}
func (m *ServerState) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerState.DiscardUnknown(m)
}

var xxx_messageInfo_ServerState proto.InternalMessageInfo

func (m *ServerState) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

type RaftLog struct {
	Op                               Op                                `protobuf:"varint,1,opt,name=op,proto3,enum=protocol.Op" json:"op,omitempty"`
	CreateStreamOp                   *CreateStreamOp                   `protobuf:"bytes,2,opt,name=createStreamOp,proto3" json:"createStreamOp,omitempty"`
	ShrinkISROp                      *ShrinkISROp                      `protobuf:"bytes,3,opt,name=shrinkISROp,proto3" json:"shrinkISROp,omitempty"`
	ChangeLeaderOp                   *ChangeLeaderOp                   `protobuf:"bytes,4,opt,name=changeLeaderOp,proto3" json:"changeLeaderOp,omitempty"`
	ExpandISROp                      *ExpandISROp                      `protobuf:"bytes,5,opt,name=expandISROp,proto3" json:"expandISROp,omitempty"`
	DeleteStreamOp                   *DeleteStreamOp                   `protobuf:"bytes,6,opt,name=deleteStreamOp,proto3" json:"deleteStreamOp,omitempty"`
	PauseStreamOp                    *PauseStreamOp                    `protobuf:"bytes,7,opt,name=pauseStreamOp,proto3" json:"pauseStreamOp,omitempty"`
	ResumeStreamOp                   *ResumeStreamOp                   `protobuf:"bytes,8,opt,name=resumeStreamOp,proto3" json:"resumeStreamOp,omitempty"`
	PublishActivityOp                *PublishActivityOp                `protobuf:"bytes,9,opt,name=publishActivityOp,proto3" json:"publishActivityOp,omitempty"`
	SetStreamReadonlyOp              *SetStreamReadonlyOp              `protobuf:"bytes,10,opt,name=setStreamReadonlyOp,proto3" json:"setStreamReadonlyOp,omitempty"`
	CreateConsumerGroupOp            *CreateConsumerGroupOp            `protobuf:"bytes,11,opt,name=createConsumerGroupOp,proto3" json:"createConsumerGroupOp,omitempty"`
	JoinConsumerGroupOp              *JoinConsumerGroupOp              `protobuf:"bytes,12,opt,name=joinConsumerGroupOp,proto3" json:"joinConsumerGroupOp,omitempty"`
	LeaveConsumerGroupOp             *LeaveConsumerGroupOp             `protobuf:"bytes,13,opt,name=leaveConsumerGroupOp,proto3" json:"leaveConsumerGroupOp,omitempty"`
	ChangeConsumerGroupCoordinatorOp *ChangeConsumerGroupCoordinatorOp `protobuf:"bytes,14,opt,name=changeConsumerGroupCoordinatorOp,proto3" json:"changeConsumerGroupCoordinatorOp,omitempty"`
	AddPolicyOp                      *AddPolicyOp                      `protobuf:"bytes,15,opt,name=addPolicyOp,proto3" json:"addPolicyOp,omitempty"`
	RevokePolicyOp                   *RevokePolicyOp                   `protobuf:"bytes,16,opt,name=revokePolicyOp,proto3" json:"revokePolicyOp,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}                          `json:"-"`
	XXX_unrecognized                 []byte                            `json:"-"`
	XXX_sizecache                    int32                             `json:"-"`
}

func (m *RaftLog) Reset()         { *m = RaftLog{} }
func (m *RaftLog) String() string { return proto.CompactTextString(m) }
func (*RaftLog) ProtoMessage()    {}
func (*RaftLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{1}
}
func (m *RaftLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftLog.Merge(m, src)
}
func (m *RaftLog) XXX_Size() int {
	return m.Size()
}
func (m *RaftLog) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftLog.DiscardUnknown(m)
}

var xxx_messageInfo_RaftLog proto.InternalMessageInfo

func (m *RaftLog) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_STREAM
}

func (m *RaftLog) GetCreateStreamOp() *CreateStreamOp {
	if m != nil {
		return m.CreateStreamOp
	}
	return nil
}

func (m *RaftLog) GetShrinkISROp() *ShrinkISROp {
	if m != nil {
		return m.ShrinkISROp
	}
	return nil
}

func (m *RaftLog) GetChangeLeaderOp() *ChangeLeaderOp {
	if m != nil {
		return m.ChangeLeaderOp
	}
	return nil
}

func (m *RaftLog) GetExpandISROp() *ExpandISROp {
	if m != nil {
		return m.ExpandISROp
	}
	return nil
}

func (m *RaftLog) GetDeleteStreamOp() *DeleteStreamOp {
	if m != nil {
		return m.DeleteStreamOp
	}
	return nil
}

func (m *RaftLog) GetPauseStreamOp() *PauseStreamOp {
	if m != nil {
		return m.PauseStreamOp
	}
	return nil
}

func (m *RaftLog) GetResumeStreamOp() *ResumeStreamOp {
	if m != nil {
		return m.ResumeStreamOp
	}
	return nil
}

func (m *RaftLog) GetPublishActivityOp() *PublishActivityOp {
	if m != nil {
		return m.PublishActivityOp
	}
	return nil
}

func (m *RaftLog) GetSetStreamReadonlyOp() *SetStreamReadonlyOp {
	if m != nil {
		return m.SetStreamReadonlyOp
	}
	return nil
}

func (m *RaftLog) GetCreateConsumerGroupOp() *CreateConsumerGroupOp {
	if m != nil {
		return m.CreateConsumerGroupOp
	}
	return nil
}

func (m *RaftLog) GetJoinConsumerGroupOp() *JoinConsumerGroupOp {
	if m != nil {
		return m.JoinConsumerGroupOp
	}
	return nil
}

func (m *RaftLog) GetLeaveConsumerGroupOp() *LeaveConsumerGroupOp {
	if m != nil {
		return m.LeaveConsumerGroupOp
	}
	return nil
}

func (m *RaftLog) GetChangeConsumerGroupCoordinatorOp() *ChangeConsumerGroupCoordinatorOp {
	if m != nil {
		return m.ChangeConsumerGroupCoordinatorOp
	}
	return nil
}

func (m *RaftLog) GetAddPolicyOp() *AddPolicyOp {
	if m != nil {
		return m.AddPolicyOp
	}
	return nil
}

func (m *RaftLog) GetRevokePolicyOp() *RevokePolicyOp {
	if m != nil {
		return m.RevokePolicyOp
	}
	return nil
}

type CreateStreamOp struct {
	Stream               *Stream  `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateStreamOp) Reset()         { *m = CreateStreamOp{} }
func (m *CreateStreamOp) String() string { return proto.CompactTextString(m) }
func (*CreateStreamOp) ProtoMessage()    {}
func (*CreateStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{2}
}
func (m *CreateStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStreamOp.Merge(m, src)
}
func (m *CreateStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *CreateStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStreamOp proto.InternalMessageInfo

func (m *CreateStreamOp) GetStream() *Stream {
	if m != nil {
		return m.Stream
	}
	return nil
}

type ShrinkISROp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ReplicaToRemove      string   `protobuf:"bytes,3,opt,name=replicaToRemove,proto3" json:"replicaToRemove,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShrinkISROp) Reset()         { *m = ShrinkISROp{} }
func (m *ShrinkISROp) String() string { return proto.CompactTextString(m) }
func (*ShrinkISROp) ProtoMessage()    {}
func (*ShrinkISROp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{3}
}
func (m *ShrinkISROp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShrinkISROp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShrinkISROp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShrinkISROp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShrinkISROp.Merge(m, src)
}
func (m *ShrinkISROp) XXX_Size() int {
	return m.Size()
}
func (m *ShrinkISROp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShrinkISROp.DiscardUnknown(m)
}

var xxx_messageInfo_ShrinkISROp proto.InternalMessageInfo

func (m *ShrinkISROp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ShrinkISROp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ShrinkISROp) GetReplicaToRemove() string {
	if m != nil {
		return m.ReplicaToRemove
	}
	return ""
}

func (m *ShrinkISROp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ShrinkISROp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ExpandISROp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	ReplicaToAdd         string   `protobuf:"bytes,3,opt,name=replicaToAdd,proto3" json:"replicaToAdd,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpandISROp) Reset()         { *m = ExpandISROp{} }
func (m *ExpandISROp) String() string { return proto.CompactTextString(m) }
func (*ExpandISROp) ProtoMessage()    {}
func (*ExpandISROp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{4}
}
func (m *ExpandISROp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpandISROp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpandISROp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpandISROp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpandISROp.Merge(m, src)
}
func (m *ExpandISROp) XXX_Size() int {
	return m.Size()
}
func (m *ExpandISROp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpandISROp.DiscardUnknown(m)
}

var xxx_messageInfo_ExpandISROp proto.InternalMessageInfo

func (m *ExpandISROp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ExpandISROp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ExpandISROp) GetReplicaToAdd() string {
	if m != nil {
		return m.ReplicaToAdd
	}
	return ""
}

func (m *ExpandISROp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ExpandISROp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type DeleteStreamOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteStreamOp) Reset()         { *m = DeleteStreamOp{} }
func (m *DeleteStreamOp) String() string { return proto.CompactTextString(m) }
func (*DeleteStreamOp) ProtoMessage()    {}
func (*DeleteStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{5}
}
func (m *DeleteStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteStreamOp.Merge(m, src)
}
func (m *DeleteStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *DeleteStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteStreamOp proto.InternalMessageInfo

func (m *DeleteStreamOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

type PauseStreamOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partitions           []int32  `protobuf:"varint,2,rep,packed,name=partitions,proto3" json:"partitions,omitempty"`
	ResumeAll            bool     `protobuf:"varint,3,opt,name=resumeAll,proto3" json:"resumeAll,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PauseStreamOp) Reset()         { *m = PauseStreamOp{} }
func (m *PauseStreamOp) String() string { return proto.CompactTextString(m) }
func (*PauseStreamOp) ProtoMessage()    {}
func (*PauseStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{6}
}
func (m *PauseStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PauseStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PauseStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PauseStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PauseStreamOp.Merge(m, src)
}
func (m *PauseStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *PauseStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_PauseStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_PauseStreamOp proto.InternalMessageInfo

func (m *PauseStreamOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PauseStreamOp) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *PauseStreamOp) GetResumeAll() bool {
	if m != nil {
		return m.ResumeAll
	}
	return false
}

type ResumeStreamOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partitions           []int32  `protobuf:"varint,2,rep,packed,name=partitions,proto3" json:"partitions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResumeStreamOp) Reset()         { *m = ResumeStreamOp{} }
func (m *ResumeStreamOp) String() string { return proto.CompactTextString(m) }
func (*ResumeStreamOp) ProtoMessage()    {}
func (*ResumeStreamOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{7}
}
func (m *ResumeStreamOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumeStreamOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResumeStreamOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResumeStreamOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumeStreamOp.Merge(m, src)
}
func (m *ResumeStreamOp) XXX_Size() int {
	return m.Size()
}
func (m *ResumeStreamOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumeStreamOp.DiscardUnknown(m)
}

var xxx_messageInfo_ResumeStreamOp proto.InternalMessageInfo

func (m *ResumeStreamOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ResumeStreamOp) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

type ReportLeaderOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Replica              string   `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica,omitempty"`
	Leader               string   `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,5,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportLeaderOp) Reset()         { *m = ReportLeaderOp{} }
func (m *ReportLeaderOp) String() string { return proto.CompactTextString(m) }
func (*ReportLeaderOp) ProtoMessage()    {}
func (*ReportLeaderOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{8}
}
func (m *ReportLeaderOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportLeaderOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportLeaderOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportLeaderOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportLeaderOp.Merge(m, src)
}
func (m *ReportLeaderOp) XXX_Size() int {
	return m.Size()
}
func (m *ReportLeaderOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportLeaderOp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportLeaderOp proto.InternalMessageInfo

func (m *ReportLeaderOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ReportLeaderOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ReportLeaderOp) GetReplica() string {
	if m != nil {
		return m.Replica
	}
	return ""
}

func (m *ReportLeaderOp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ReportLeaderOp) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type ChangeLeaderOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	Leader               string   `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeLeaderOp) Reset()         { *m = ChangeLeaderOp{} }
func (m *ChangeLeaderOp) String() string { return proto.CompactTextString(m) }
func (*ChangeLeaderOp) ProtoMessage()    {}
func (*ChangeLeaderOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{9}
}
func (m *ChangeLeaderOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeLeaderOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeLeaderOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeLeaderOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeLeaderOp.Merge(m, src)
}
func (m *ChangeLeaderOp) XXX_Size() int {
	return m.Size()
}
func (m *ChangeLeaderOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeLeaderOp.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeLeaderOp proto.InternalMessageInfo

func (m *ChangeLeaderOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *ChangeLeaderOp) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *ChangeLeaderOp) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

type ReportConsumerGroupCoordinatorOp struct {
	GroupId              string   `protobuf:"bytes,1,opt,name=groupId,proto3" json:"groupId,omitempty"`
	ConsumerId           string   `protobuf:"bytes,2,opt,name=consumerId,proto3" json:"consumerId,omitempty"`
	Coordinator          string   `protobuf:"bytes,3,opt,name=coordinator,proto3" json:"coordinator,omitempty"`
	Epoch                uint64   `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportConsumerGroupCoordinatorOp) Reset()         { *m = ReportConsumerGroupCoordinatorOp{} }
func (m *ReportConsumerGroupCoordinatorOp) String() string { return proto.CompactTextString(m) }
func (*ReportConsumerGroupCoordinatorOp) ProtoMessage()    {}
func (*ReportConsumerGroupCoordinatorOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{10}
}
func (m *ReportConsumerGroupCoordinatorOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportConsumerGroupCoordinatorOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportConsumerGroupCoordinatorOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportConsumerGroupCoordinatorOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportConsumerGroupCoordinatorOp.Merge(m, src)
}
func (m *ReportConsumerGroupCoordinatorOp) XXX_Size() int {
	return m.Size()
}
func (m *ReportConsumerGroupCoordinatorOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportConsumerGroupCoordinatorOp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportConsumerGroupCoordinatorOp proto.InternalMessageInfo

func (m *ReportConsumerGroupCoordinatorOp) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *ReportConsumerGroupCoordinatorOp) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

func (m *ReportConsumerGroupCoordinatorOp) GetCoordinator() string {
	if m != nil {
		return m.Coordinator
	}
	return ""
}

func (m *ReportConsumerGroupCoordinatorOp) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type ChangeConsumerGroupCoordinatorOp struct {
	GroupId              string   `protobuf:"bytes,1,opt,name=groupId,proto3" json:"groupId,omitempty"`
	Coordinator          string   `protobuf:"bytes,2,opt,name=coordinator,proto3" json:"coordinator,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeConsumerGroupCoordinatorOp) Reset()         { *m = ChangeConsumerGroupCoordinatorOp{} }
func (m *ChangeConsumerGroupCoordinatorOp) String() string { return proto.CompactTextString(m) }
func (*ChangeConsumerGroupCoordinatorOp) ProtoMessage()    {}
func (*ChangeConsumerGroupCoordinatorOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{11}
}
func (m *ChangeConsumerGroupCoordinatorOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeConsumerGroupCoordinatorOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeConsumerGroupCoordinatorOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeConsumerGroupCoordinatorOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeConsumerGroupCoordinatorOp.Merge(m, src)
}
func (m *ChangeConsumerGroupCoordinatorOp) XXX_Size() int {
	return m.Size()
}
func (m *ChangeConsumerGroupCoordinatorOp) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeConsumerGroupCoordinatorOp.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeConsumerGroupCoordinatorOp proto.InternalMessageInfo

func (m *ChangeConsumerGroupCoordinatorOp) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *ChangeConsumerGroupCoordinatorOp) GetCoordinator() string {
	if m != nil {
		return m.Coordinator
	}
	return ""
}

type PublishActivityOp struct {
	RaftIndex            uint64   `protobuf:"varint,1,opt,name=raftIndex,proto3" json:"raftIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublishActivityOp) Reset()         { *m = PublishActivityOp{} }
func (m *PublishActivityOp) String() string { return proto.CompactTextString(m) }
func (*PublishActivityOp) ProtoMessage()    {}
func (*PublishActivityOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{12}
}
func (m *PublishActivityOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishActivityOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishActivityOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishActivityOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishActivityOp.Merge(m, src)
}
func (m *PublishActivityOp) XXX_Size() int {
	return m.Size()
}
func (m *PublishActivityOp) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishActivityOp.DiscardUnknown(m)
}

var xxx_messageInfo_PublishActivityOp proto.InternalMessageInfo

func (m *PublishActivityOp) GetRaftIndex() uint64 {
	if m != nil {
		return m.RaftIndex
	}
	return 0
}

type SetStreamReadonlyOp struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partitions           []int32  `protobuf:"varint,2,rep,packed,name=partitions,proto3" json:"partitions,omitempty"`
	Readonly             bool     `protobuf:"varint,3,opt,name=readonly,proto3" json:"readonly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetStreamReadonlyOp) Reset()         { *m = SetStreamReadonlyOp{} }
func (m *SetStreamReadonlyOp) String() string { return proto.CompactTextString(m) }
func (*SetStreamReadonlyOp) ProtoMessage()    {}
func (*SetStreamReadonlyOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{13}
}
func (m *SetStreamReadonlyOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetStreamReadonlyOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetStreamReadonlyOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetStreamReadonlyOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetStreamReadonlyOp.Merge(m, src)
}
func (m *SetStreamReadonlyOp) XXX_Size() int {
	return m.Size()
}
func (m *SetStreamReadonlyOp) XXX_DiscardUnknown() {
	xxx_messageInfo_SetStreamReadonlyOp.DiscardUnknown(m)
}

var xxx_messageInfo_SetStreamReadonlyOp proto.InternalMessageInfo

func (m *SetStreamReadonlyOp) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *SetStreamReadonlyOp) GetPartitions() []int32 {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *SetStreamReadonlyOp) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type CreateConsumerGroupOp struct {
	ConsumerGroup        *ConsumerGroup `protobuf:"bytes,1,opt,name=consumerGroup,proto3" json:"consumerGroup,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CreateConsumerGroupOp) Reset()         { *m = CreateConsumerGroupOp{} }
func (m *CreateConsumerGroupOp) String() string { return proto.CompactTextString(m) }
func (*CreateConsumerGroupOp) ProtoMessage()    {}
func (*CreateConsumerGroupOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{14}
}
func (m *CreateConsumerGroupOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateConsumerGroupOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateConsumerGroupOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateConsumerGroupOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateConsumerGroupOp.Merge(m, src)
}
func (m *CreateConsumerGroupOp) XXX_Size() int {
	return m.Size()
}
func (m *CreateConsumerGroupOp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateConsumerGroupOp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateConsumerGroupOp proto.InternalMessageInfo

func (m *CreateConsumerGroupOp) GetConsumerGroup() *ConsumerGroup {
	if m != nil {
		return m.ConsumerGroup
	}
	return nil
}

type JoinConsumerGroupOp struct {
	GroupId              string   `protobuf:"bytes,1,opt,name=groupId,proto3" json:"groupId,omitempty"`
	ConsumerId           string   `protobuf:"bytes,2,opt,name=consumerId,proto3" json:"consumerId,omitempty"`
	Streams              []string `protobuf:"bytes,3,rep,name=streams,proto3" json:"streams,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JoinConsumerGroupOp) Reset()         { *m = JoinConsumerGroupOp{} }
func (m *JoinConsumerGroupOp) String() string { return proto.CompactTextString(m) }
func (*JoinConsumerGroupOp) ProtoMessage()    {}
func (*JoinConsumerGroupOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{15}
}
func (m *JoinConsumerGroupOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JoinConsumerGroupOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JoinConsumerGroupOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JoinConsumerGroupOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinConsumerGroupOp.Merge(m, src)
}
func (m *JoinConsumerGroupOp) XXX_Size() int {
	return m.Size()
}
func (m *JoinConsumerGroupOp) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinConsumerGroupOp.DiscardUnknown(m)
}

var xxx_messageInfo_JoinConsumerGroupOp proto.InternalMessageInfo

func (m *JoinConsumerGroupOp) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *JoinConsumerGroupOp) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

func (m *JoinConsumerGroupOp) GetStreams() []string {
	if m != nil {
		return m.Streams
	}
	return nil
}

type LeaveConsumerGroupOp struct {
	GroupId              string   `protobuf:"bytes,1,opt,name=groupId,proto3" json:"groupId,omitempty"`
	ConsumerId           string   `protobuf:"bytes,2,opt,name=consumerId,proto3" json:"consumerId,omitempty"`
	Expired              bool     `protobuf:"varint,3,opt,name=expired,proto3" json:"expired,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaveConsumerGroupOp) Reset()         { *m = LeaveConsumerGroupOp{} }
func (m *LeaveConsumerGroupOp) String() string { return proto.CompactTextString(m) }
func (*LeaveConsumerGroupOp) ProtoMessage()    {}
func (*LeaveConsumerGroupOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{16}
}
func (m *LeaveConsumerGroupOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaveConsumerGroupOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaveConsumerGroupOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaveConsumerGroupOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaveConsumerGroupOp.Merge(m, src)
}
func (m *LeaveConsumerGroupOp) XXX_Size() int {
	return m.Size()
}
func (m *LeaveConsumerGroupOp) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaveConsumerGroupOp.DiscardUnknown(m)
}

var xxx_messageInfo_LeaveConsumerGroupOp proto.InternalMessageInfo

func (m *LeaveConsumerGroupOp) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *LeaveConsumerGroupOp) GetConsumerId() string {
	if m != nil {
		return m.ConsumerId
	}
	return ""
}

func (m *LeaveConsumerGroupOp) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

// Policy represents an ACL-style policy
type Policy struct {
	UserId               string   `protobuf:"bytes,1,opt,name=userId,proto3" json:"userId,omitempty"`
	ResourceId           string   `protobuf:"bytes,2,opt,name=resourceId,proto3" json:"resourceId,omitempty"`
	Action               string   `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Policy) Reset()         { *m = Policy{} }
func (m *Policy) String() string { return proto.CompactTextString(m) }
func (*Policy) ProtoMessage()    {}
func (*Policy) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{17}
}
func (m *Policy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Policy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Policy.Merge(m, src)
}
func (m *Policy) XXX_Size() int {
	return m.Size()
}
func (m *Policy) XXX_DiscardUnknown() {
	xxx_messageInfo_Policy.DiscardUnknown(m)
}

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Policy) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *Policy) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

// AddPolicyOp adds an ACL-style policy
type AddPolicyOp struct {
	Policy               *Policy  `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddPolicyOp) Reset()         { *m = AddPolicyOp{} }
func (m *AddPolicyOp) String() string { return proto.CompactTextString(m) }
func (*AddPolicyOp) ProtoMessage()    {}
func (*AddPolicyOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{18}
}
func (m *AddPolicyOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPolicyOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPolicyOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPolicyOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPolicyOp.Merge(m, src)
}
func (m *AddPolicyOp) XXX_Size() int {
	return m.Size()
}
func (m *AddPolicyOp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPolicyOp.DiscardUnknown(m)
}

var xxx_messageInfo_AddPolicyOp proto.InternalMessageInfo

func (m *AddPolicyOp) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

// RevokePolicyOp removes an ACL-style policy
type RevokePolicyOp struct {
	Policy               *Policy  `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RevokePolicyOp) Reset()         { *m = RevokePolicyOp{} }
func (m *RevokePolicyOp) String() string { return proto.CompactTextString(m) }
func (*RevokePolicyOp) ProtoMessage()    {}
func (*RevokePolicyOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{19}
}
func (m *RevokePolicyOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevokePolicyOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevokePolicyOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RevokePolicyOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokePolicyOp.Merge(m, src)
}
func (m *RevokePolicyOp) XXX_Size() int {
	return m.Size()
}
func (m *RevokePolicyOp) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokePolicyOp.DiscardUnknown(m)
}

var xxx_messageInfo_RevokePolicyOp proto.InternalMessageInfo

func (m *RevokePolicyOp) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type NullableInt64 struct {
	Value                int64    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullableInt64) Reset()         { *m = NullableInt64{} }
func (m *NullableInt64) String() string { return proto.CompactTextString(m) }
func (*NullableInt64) ProtoMessage()    {}
func (*NullableInt64) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{20}
}
func (m *NullableInt64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableInt64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableInt64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableInt64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableInt64.Merge(m, src)
}
func (m *NullableInt64) XXX_Size() int {
	return m.Size()
}
func (m *NullableInt64) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableInt64.DiscardUnknown(m)
}

var xxx_messageInfo_NullableInt64 proto.InternalMessageInfo

func (m *NullableInt64) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type NullableInt32 struct {
	Value                int32    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullableInt32) Reset()         { *m = NullableInt32{} }
func (m *NullableInt32) String() string { return proto.CompactTextString(m) }
func (*NullableInt32) ProtoMessage()    {}
func (*NullableInt32) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{21}
}
func (m *NullableInt32) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableInt32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableInt32.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableInt32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableInt32.Merge(m, src)
}
func (m *NullableInt32) XXX_Size() int {
	return m.Size()
}
func (m *NullableInt32) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableInt32.DiscardUnknown(m)
}

var xxx_messageInfo_NullableInt32 proto.InternalMessageInfo

func (m *NullableInt32) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

type NullableBool struct {
	Value                bool     `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullableBool) Reset()         { *m = NullableBool{} }
func (m *NullableBool) String() string { return proto.CompactTextString(m) }
func (*NullableBool) ProtoMessage()    {}
func (*NullableBool) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{22}
}
func (m *NullableBool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableBool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableBool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableBool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableBool.Merge(m, src)
}
func (m *NullableBool) XXX_Size() int {
	return m.Size()
}
func (m *NullableBool) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableBool.DiscardUnknown(m)
}

var xxx_messageInfo_NullableBool proto.InternalMessageInfo

func (m *NullableBool) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

type StreamConfig struct {
	RetentionMaxBytes             *NullableInt64 `protobuf:"bytes,1,opt,name=retentionMaxBytes,proto3" json:"retentionMaxBytes,omitempty"`
	RetentionMaxMessages          *NullableInt64 `protobuf:"bytes,2,opt,name=retentionMaxMessages,proto3" json:"retentionMaxMessages,omitempty"`
	RetentionMaxAge               *NullableInt64 `protobuf:"bytes,3,opt,name=retentionMaxAge,proto3" json:"retentionMaxAge,omitempty"`
	CleanerInterval               *NullableInt64 `protobuf:"bytes,4,opt,name=cleanerInterval,proto3" json:"cleanerInterval,omitempty"`
	SegmentMaxBytes               *NullableInt64 `protobuf:"bytes,5,opt,name=segmentMaxBytes,proto3" json:"segmentMaxBytes,omitempty"`
	SegmentMaxAge                 *NullableInt64 `protobuf:"bytes,6,opt,name=segmentMaxAge,proto3" json:"segmentMaxAge,omitempty"`
	CompactMaxGoroutines          *NullableInt32 `protobuf:"bytes,7,opt,name=compactMaxGoroutines,proto3" json:"compactMaxGoroutines,omitempty"`
	CompactEnabled                *NullableBool  `protobuf:"bytes,8,opt,name=compactEnabled,proto3" json:"compactEnabled,omitempty"`
	AutoPauseTime                 *NullableInt64 `protobuf:"bytes,9,opt,name=autoPauseTime,proto3" json:"autoPauseTime,omitempty"`
	AutoPauseDisableIfSubscribers *NullableBool  `protobuf:"bytes,10,opt,name=autoPauseDisableIfSubscribers,proto3" json:"autoPauseDisableIfSubscribers,omitempty"`
	MinIsr                        *NullableInt32 `protobuf:"bytes,11,opt,name=minIsr,proto3" json:"minIsr,omitempty"`
	OptimisticConcurrencyControl  *NullableBool  `protobuf:"bytes,12,opt,name=optimisticConcurrencyControl,proto3" json:"optimisticConcurrencyControl,omitempty"`
	Encryption                    *NullableBool  `protobuf:"bytes,13,opt,name=encryption,proto3" json:"encryption,omitempty"`
	XXX_NoUnkeyedLiteral          struct{}       `json:"-"`
	XXX_unrecognized              []byte         `json:"-"`
	XXX_sizecache                 int32          `json:"-"`
}

func (m *StreamConfig) Reset()         { *m = StreamConfig{} }
func (m *StreamConfig) String() string { return proto.CompactTextString(m) }
func (*StreamConfig) ProtoMessage()    {}
func (*StreamConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{23}
}
func (m *StreamConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamConfig.Merge(m, src)
}
func (m *StreamConfig) XXX_Size() int {
	return m.Size()
}
func (m *StreamConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StreamConfig proto.InternalMessageInfo

func (m *StreamConfig) GetRetentionMaxBytes() *NullableInt64 {
	if m != nil {
		return m.RetentionMaxBytes
	}
	return nil
}

func (m *StreamConfig) GetRetentionMaxMessages() *NullableInt64 {
	if m != nil {
		return m.RetentionMaxMessages
	}
	return nil
}

func (m *StreamConfig) GetRetentionMaxAge() *NullableInt64 {
	if m != nil {
		return m.RetentionMaxAge
	}
	return nil
}

func (m *StreamConfig) GetCleanerInterval() *NullableInt64 {
	if m != nil {
		return m.CleanerInterval
	}
	return nil
}

func (m *StreamConfig) GetSegmentMaxBytes() *NullableInt64 {
	if m != nil {
		return m.SegmentMaxBytes
	}
	return nil
}

func (m *StreamConfig) GetSegmentMaxAge() *NullableInt64 {
	if m != nil {
		return m.SegmentMaxAge
	}
	return nil
}

func (m *StreamConfig) GetCompactMaxGoroutines() *NullableInt32 {
	if m != nil {
		return m.CompactMaxGoroutines
	}
	return nil
}

func (m *StreamConfig) GetCompactEnabled() *NullableBool {
	if m != nil {
		return m.CompactEnabled
	}
	return nil
}

func (m *StreamConfig) GetAutoPauseTime() *NullableInt64 {
	if m != nil {
		return m.AutoPauseTime
	}
	return nil
}

func (m *StreamConfig) GetAutoPauseDisableIfSubscribers() *NullableBool {
	if m != nil {
		return m.AutoPauseDisableIfSubscribers
	}
	return nil
}

func (m *StreamConfig) GetMinIsr() *NullableInt32 {
	if m != nil {
		return m.MinIsr
	}
	return nil
}

func (m *StreamConfig) GetOptimisticConcurrencyControl() *NullableBool {
	if m != nil {
		return m.OptimisticConcurrencyControl
	}
	return nil
}

func (m *StreamConfig) GetEncryption() *NullableBool {
	if m != nil {
		return m.Encryption
	}
	return nil
}

type Stream struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Subject              string        `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	Partitions           []*Partition  `protobuf:"bytes,3,rep,name=partitions,proto3" json:"partitions,omitempty"`
	Config               *StreamConfig `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	CreationTimestamp    int64         `protobuf:"varint,5,opt,name=creationTimestamp,proto3" json:"creationTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Stream) Reset()         { *m = Stream{} }
func (m *Stream) String() string { return proto.CompactTextString(m) }
func (*Stream) ProtoMessage()    {}
func (*Stream) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{24}
}
func (m *Stream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stream.Merge(m, src)
}
func (m *Stream) XXX_Size() int {
	return m.Size()
}
func (m *Stream) XXX_DiscardUnknown() {
	xxx_messageInfo_Stream.DiscardUnknown(m)
}

var xxx_messageInfo_Stream proto.InternalMessageInfo

func (m *Stream) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Stream) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Stream) GetPartitions() []*Partition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *Stream) GetConfig() *StreamConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Stream) GetCreationTimestamp() int64 {
	if m != nil {
		return m.CreationTimestamp
	}
	return 0
}

type Partition struct {
	Subject              string   `protobuf:"bytes,1,opt,name=subject,proto3" json:"subject,omitempty"`
	Stream               string   `protobuf:"bytes,2,opt,name=stream,proto3" json:"stream,omitempty"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	Group                string   `protobuf:"bytes,4,opt,name=group,proto3" json:"group,omitempty"`
	ReplicationFactor    int32    `protobuf:"varint,5,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	Replicas             []string `protobuf:"bytes,6,rep,name=replicas,proto3" json:"replicas,omitempty"`
	Leader               string   `protobuf:"bytes,7,opt,name=leader,proto3" json:"leader,omitempty"`
	Isr                  []string `protobuf:"bytes,8,rep,name=isr,proto3" json:"isr,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,9,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	Epoch                uint64   `protobuf:"varint,10,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Paused               bool     `protobuf:"varint,11,opt,name=paused,proto3" json:"paused,omitempty"`
	Readonly             bool     `protobuf:"varint,12,opt,name=readonly,proto3" json:"readonly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Partition) Reset()         { *m = Partition{} }
func (m *Partition) String() string { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()    {}
func (*Partition) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{25}
}
func (m *Partition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Partition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Partition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Partition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Partition.Merge(m, src)
}
func (m *Partition) XXX_Size() int {
	return m.Size()
}
func (m *Partition) XXX_DiscardUnknown() {
	xxx_messageInfo_Partition.DiscardUnknown(m)
}

var xxx_messageInfo_Partition proto.InternalMessageInfo

func (m *Partition) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *Partition) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *Partition) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Partition) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Partition) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *Partition) GetReplicas() []string {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *Partition) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Partition) GetIsr() []string {
	if m != nil {
		return m.Isr
	}
	return nil
}

func (m *Partition) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

func (m *Partition) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Partition) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *Partition) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type Consumer struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Streams              []string `protobuf:"bytes,2,rep,name=streams,proto3" json:"streams,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Consumer) Reset()         { *m = Consumer{} }
func (m *Consumer) String() string { return proto.CompactTextString(m) }
func (*Consumer) ProtoMessage()    {}
func (*Consumer) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{26}
}
func (m *Consumer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Consumer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Consumer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Consumer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Consumer.Merge(m, src)
}
func (m *Consumer) XXX_Size() int {
	return m.Size()
}
func (m *Consumer) XXX_DiscardUnknown() {
	xxx_messageInfo_Consumer.DiscardUnknown(m)
}

var xxx_messageInfo_Consumer proto.InternalMessageInfo

func (m *Consumer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Consumer) GetStreams() []string {
	if m != nil {
		return m.Streams
	}
	return nil
}

type ConsumerGroup struct {
	Id                   string      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Members              []*Consumer `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	Coordinator          string      `protobuf:"bytes,3,opt,name=coordinator,proto3" json:"coordinator,omitempty"`
	Epoch                uint64      `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ConsumerGroup) Reset()         { *m = ConsumerGroup{} }
func (m *ConsumerGroup) String() string { return proto.CompactTextString(m) }
func (*ConsumerGroup) ProtoMessage()    {}
func (*ConsumerGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{27}
}
func (m *ConsumerGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumerGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumerGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsumerGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerGroup.Merge(m, src)
}
func (m *ConsumerGroup) XXX_Size() int {
	return m.Size()
}
func (m *ConsumerGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerGroup proto.InternalMessageInfo

func (m *ConsumerGroup) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ConsumerGroup) GetMembers() []*Consumer {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *ConsumerGroup) GetCoordinator() string {
	if m != nil {
		return m.Coordinator
	}
	return ""
}

func (m *ConsumerGroup) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

// RaftJoinRequest is a request to join a Raft group.
type RaftJoinRequest struct {
	NodeID               string   `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
	NodeAddr             string   `protobuf:"bytes,2,opt,name=nodeAddr,proto3" json:"nodeAddr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftJoinRequest) Reset()         { *m = RaftJoinRequest{} }
func (m *RaftJoinRequest) String() string { return proto.CompactTextString(m) }
func (*RaftJoinRequest) ProtoMessage()    {}
func (*RaftJoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{28}
}
func (m *RaftJoinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftJoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftJoinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftJoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftJoinRequest.Merge(m, src)
}
func (m *RaftJoinRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftJoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftJoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftJoinRequest proto.InternalMessageInfo

func (m *RaftJoinRequest) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

func (m *RaftJoinRequest) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

// RaftJoinResponse is a response to a RaftJoinRequest.
type RaftJoinResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftJoinResponse) Reset()         { *m = RaftJoinResponse{} }
func (m *RaftJoinResponse) String() string { return proto.CompactTextString(m) }
func (*RaftJoinResponse) ProtoMessage()    {}
func (*RaftJoinResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{29}
}
func (m *RaftJoinResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftJoinResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftJoinResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftJoinResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftJoinResponse.Merge(m, src)
}
func (m *RaftJoinResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftJoinResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftJoinResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftJoinResponse proto.InternalMessageInfo

func (m *RaftJoinResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type MetadataSnapshot struct {
	Streams              []*Stream        `protobuf:"bytes,1,rep,name=streams,proto3" json:"streams,omitempty"`
	Groups               []*ConsumerGroup `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MetadataSnapshot) Reset()         { *m = MetadataSnapshot{} }
func (m *MetadataSnapshot) String() string { return proto.CompactTextString(m) }
func (*MetadataSnapshot) ProtoMessage()    {}
func (*MetadataSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{30}
}
func (m *MetadataSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataSnapshot.Merge(m, src)
}
func (m *MetadataSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *MetadataSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataSnapshot proto.InternalMessageInfo

func (m *MetadataSnapshot) GetStreams() []*Stream {
	if m != nil {
		return m.Streams
	}
	return nil
}

func (m *MetadataSnapshot) GetGroups() []*ConsumerGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

type ReplicationRequest struct {
	ReplicaID            string   `protobuf:"bytes,1,opt,name=replicaID,proto3" json:"replicaID,omitempty"`
	Offset               int64    `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	LeaderEpoch          uint64   `protobuf:"varint,3,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationRequest) Reset()         { *m = ReplicationRequest{} }
func (m *ReplicationRequest) String() string { return proto.CompactTextString(m) }
func (*ReplicationRequest) ProtoMessage()    {}
func (*ReplicationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{31}
}
func (m *ReplicationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicationRequest.Merge(m, src)
}
func (m *ReplicationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReplicationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicationRequest proto.InternalMessageInfo

func (m *ReplicationRequest) GetReplicaID() string {
	if m != nil {
		return m.ReplicaID
	}
	return ""
}

func (m *ReplicationRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ReplicationRequest) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type LeaderEpochOffsetRequest struct {
	LeaderEpoch          uint64   `protobuf:"varint,1,opt,name=leaderEpoch,proto3" json:"leaderEpoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderEpochOffsetRequest) Reset()         { *m = LeaderEpochOffsetRequest{} }
func (m *LeaderEpochOffsetRequest) String() string { return proto.CompactTextString(m) }
func (*LeaderEpochOffsetRequest) ProtoMessage()    {}
func (*LeaderEpochOffsetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{32}
}
func (m *LeaderEpochOffsetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderEpochOffsetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderEpochOffsetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderEpochOffsetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderEpochOffsetRequest.Merge(m, src)
}
func (m *LeaderEpochOffsetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaderEpochOffsetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderEpochOffsetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderEpochOffsetRequest proto.InternalMessageInfo

func (m *LeaderEpochOffsetRequest) GetLeaderEpoch() uint64 {
	if m != nil {
		return m.LeaderEpoch
	}
	return 0
}

type LeaderEpochOffsetResponse struct {
	EndOffset            int64    `protobuf:"varint,1,opt,name=endOffset,proto3" json:"endOffset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderEpochOffsetResponse) Reset()         { *m = LeaderEpochOffsetResponse{} }
func (m *LeaderEpochOffsetResponse) String() string { return proto.CompactTextString(m) }
func (*LeaderEpochOffsetResponse) ProtoMessage()    {}
func (*LeaderEpochOffsetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{33}
}
func (m *LeaderEpochOffsetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaderEpochOffsetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaderEpochOffsetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaderEpochOffsetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderEpochOffsetResponse.Merge(m, src)
}
func (m *LeaderEpochOffsetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LeaderEpochOffsetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderEpochOffsetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderEpochOffsetResponse proto.InternalMessageInfo

func (m *LeaderEpochOffsetResponse) GetEndOffset() int64 {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

type PropagatedRequest struct {
	Op                               Op                                `protobuf:"varint,1,opt,name=op,proto3,enum=protocol.Op" json:"op,omitempty"`
	CreateStreamOp                   *CreateStreamOp                   `protobuf:"bytes,2,opt,name=createStreamOp,proto3" json:"createStreamOp,omitempty"`
	ShrinkISROp                      *ShrinkISROp                      `protobuf:"bytes,3,opt,name=shrinkISROp,proto3" json:"shrinkISROp,omitempty"`
	ReportLeaderOp                   *ReportLeaderOp                   `protobuf:"bytes,4,opt,name=reportLeaderOp,proto3" json:"reportLeaderOp,omitempty"`
	ExpandISROp                      *ExpandISROp                      `protobuf:"bytes,5,opt,name=expandISROp,proto3" json:"expandISROp,omitempty"`
	DeleteStreamOp                   *DeleteStreamOp                   `protobuf:"bytes,6,opt,name=deleteStreamOp,proto3" json:"deleteStreamOp,omitempty"`
	PauseStreamOp                    *PauseStreamOp                    `protobuf:"bytes,7,opt,name=pauseStreamOp,proto3" json:"pauseStreamOp,omitempty"`
	ResumeStreamOp                   *ResumeStreamOp                   `protobuf:"bytes,8,opt,name=resumeStreamOp,proto3" json:"resumeStreamOp,omitempty"`
	SetStreamReadonlyOp              *SetStreamReadonlyOp              `protobuf:"bytes,9,opt,name=setStreamReadonlyOp,proto3" json:"setStreamReadonlyOp,omitempty"`
	JoinConsumerGroupOp              *JoinConsumerGroupOp              `protobuf:"bytes,10,opt,name=joinConsumerGroupOp,proto3" json:"joinConsumerGroupOp,omitempty"`
	LeaveConsumerGroupOp             *LeaveConsumerGroupOp             `protobuf:"bytes,11,opt,name=leaveConsumerGroupOp,proto3" json:"leaveConsumerGroupOp,omitempty"`
	ReportConsumerGroupCoordinatorOp *ReportConsumerGroupCoordinatorOp `protobuf:"bytes,12,opt,name=reportConsumerGroupCoordinatorOp,proto3" json:"reportConsumerGroupCoordinatorOp,omitempty"`
	AddPolicyOp                      *AddPolicyOp                      `protobuf:"bytes,13,opt,name=addPolicyOp,proto3" json:"addPolicyOp,omitempty"`
	RevokePolicyOp                   *RevokePolicyOp                   `protobuf:"bytes,14,opt,name=revokePolicyOp,proto3" json:"revokePolicyOp,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}                          `json:"-"`
	XXX_unrecognized                 []byte                            `json:"-"`
	XXX_sizecache                    int32                             `json:"-"`
}

func (m *PropagatedRequest) Reset()         { *m = PropagatedRequest{} }
func (m *PropagatedRequest) String() string { return proto.CompactTextString(m) }
func (*PropagatedRequest) ProtoMessage()    {}
func (*PropagatedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{34}
}
func (m *PropagatedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedRequest.Merge(m, src)
}
func (m *PropagatedRequest) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedRequest proto.InternalMessageInfo

func (m *PropagatedRequest) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_STREAM
}

func (m *PropagatedRequest) GetCreateStreamOp() *CreateStreamOp {
	if m != nil {
		return m.CreateStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetShrinkISROp() *ShrinkISROp {
	if m != nil {
		return m.ShrinkISROp
	}
	return nil
}

func (m *PropagatedRequest) GetReportLeaderOp() *ReportLeaderOp {
	if m != nil {
		return m.ReportLeaderOp
	}
	return nil
}

func (m *PropagatedRequest) GetExpandISROp() *ExpandISROp {
	if m != nil {
		return m.ExpandISROp
	}
	return nil
}

func (m *PropagatedRequest) GetDeleteStreamOp() *DeleteStreamOp {
	if m != nil {
		return m.DeleteStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetPauseStreamOp() *PauseStreamOp {
	if m != nil {
		return m.PauseStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetResumeStreamOp() *ResumeStreamOp {
	if m != nil {
		return m.ResumeStreamOp
	}
	return nil
}

func (m *PropagatedRequest) GetSetStreamReadonlyOp() *SetStreamReadonlyOp {
	if m != nil {
		return m.SetStreamReadonlyOp
	}
	return nil
}

func (m *PropagatedRequest) GetJoinConsumerGroupOp() *JoinConsumerGroupOp {
	if m != nil {
		return m.JoinConsumerGroupOp
	}
	return nil
}

func (m *PropagatedRequest) GetLeaveConsumerGroupOp() *LeaveConsumerGroupOp {
	if m != nil {
		return m.LeaveConsumerGroupOp
	}
	return nil
}

func (m *PropagatedRequest) GetReportConsumerGroupCoordinatorOp() *ReportConsumerGroupCoordinatorOp {
	if m != nil {
		return m.ReportConsumerGroupCoordinatorOp
	}
	return nil
}

func (m *PropagatedRequest) GetAddPolicyOp() *AddPolicyOp {
	if m != nil {
		return m.AddPolicyOp
	}
	return nil
}

func (m *PropagatedRequest) GetRevokePolicyOp() *RevokePolicyOp {
	if m != nil {
		return m.RevokePolicyOp
	}
	return nil
}

type Error struct {
	Code                 uint32   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{35}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type PropagatedResponse struct {
	Op                    Op                                            `protobuf:"varint,1,opt,name=op,proto3,enum=protocol.Op" json:"op,omitempty"`
	Error                 *Error                                        `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	JoinConsumerGroupResp *PropagatedResponse_JoinConsumerGroupResponse `protobuf:"bytes,11,opt,name=joinConsumerGroupResp,proto3" json:"joinConsumerGroupResp,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                                      `json:"-"`
	XXX_unrecognized      []byte                                        `json:"-"`
	XXX_sizecache         int32                                         `json:"-"`
}

func (m *PropagatedResponse) Reset()         { *m = PropagatedResponse{} }
func (m *PropagatedResponse) String() string { return proto.CompactTextString(m) }
func (*PropagatedResponse) ProtoMessage()    {}
func (*PropagatedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{36}
}
func (m *PropagatedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedResponse.Merge(m, src)
}
func (m *PropagatedResponse) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedResponse proto.InternalMessageInfo

func (m *PropagatedResponse) GetOp() Op {
	if m != nil {
		return m.Op
	}
	return Op_CREATE_STREAM
}

func (m *PropagatedResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *PropagatedResponse) GetJoinConsumerGroupResp() *PropagatedResponse_JoinConsumerGroupResponse {
	if m != nil {
		return m.JoinConsumerGroupResp
	}
	return nil
}

// Reserving = 3 for createStreamResp if needed.
// Reserving = 4 for shrinkISRResp if needed.
// Reserving = 5 for reportLeaderResp if needed.
// Reserving = 6 for expandISRResp if needed.
// Reserving = 7 for deleteStreamResp if needed.
// Reserving = 8 for pauseStreamResp if needed.
// Reserving = 9 for resumeStreamResp if needed.
// Reserving = 10 for setStreamReadonlyResp if needed.
type PropagatedResponse_JoinConsumerGroupResponse struct {
	Coordinator          string   `protobuf:"bytes,1,opt,name=coordinator,proto3" json:"coordinator,omitempty"`
	Epoch                uint64   `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PropagatedResponse_JoinConsumerGroupResponse) Reset() {
	*m = PropagatedResponse_JoinConsumerGroupResponse{}
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) String() string {
	return proto.CompactTextString(m)
}
func (*PropagatedResponse_JoinConsumerGroupResponse) ProtoMessage() {}
func (*PropagatedResponse_JoinConsumerGroupResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{36, 0}
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropagatedResponse_JoinConsumerGroupResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropagatedResponse_JoinConsumerGroupResponse.Merge(m, src)
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) XXX_Size() int {
	return m.Size()
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PropagatedResponse_JoinConsumerGroupResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PropagatedResponse_JoinConsumerGroupResponse proto.InternalMessageInfo

func (m *PropagatedResponse_JoinConsumerGroupResponse) GetCoordinator() string {
	if m != nil {
		return m.Coordinator
	}
	return ""
}

func (m *PropagatedResponse_JoinConsumerGroupResponse) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type ServerInfoRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfoRequest) Reset()         { *m = ServerInfoRequest{} }
func (m *ServerInfoRequest) String() string { return proto.CompactTextString(m) }
func (*ServerInfoRequest) ProtoMessage()    {}
func (*ServerInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{37}
}
func (m *ServerInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoRequest.Merge(m, src)
}
func (m *ServerInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoRequest proto.InternalMessageInfo

func (m *ServerInfoRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ServerInfoResponse struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Host                 string   `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	Port                 int32    `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerInfoResponse) Reset()         { *m = ServerInfoResponse{} }
func (m *ServerInfoResponse) String() string { return proto.CompactTextString(m) }
func (*ServerInfoResponse) ProtoMessage()    {}
func (*ServerInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{38}
}
func (m *ServerInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoResponse.Merge(m, src)
}
func (m *ServerInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoResponse proto.InternalMessageInfo

func (m *ServerInfoResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ServerInfoResponse) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ServerInfoResponse) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type PartitionStatusRequest struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionStatusRequest) Reset()         { *m = PartitionStatusRequest{} }
func (m *PartitionStatusRequest) String() string { return proto.CompactTextString(m) }
func (*PartitionStatusRequest) ProtoMessage()    {}
func (*PartitionStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{39}
}
func (m *PartitionStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatusRequest.Merge(m, src)
}
func (m *PartitionStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatusRequest proto.InternalMessageInfo

func (m *PartitionStatusRequest) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PartitionStatusRequest) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type PartitionStatusResponse struct {
	Exists               bool     `protobuf:"varint,1,opt,name=exists,proto3" json:"exists,omitempty"`
	IsLeader             bool     `protobuf:"varint,2,opt,name=isLeader,proto3" json:"isLeader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionStatusResponse) Reset()         { *m = PartitionStatusResponse{} }
func (m *PartitionStatusResponse) String() string { return proto.CompactTextString(m) }
func (*PartitionStatusResponse) ProtoMessage()    {}
func (*PartitionStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{40}
}
func (m *PartitionStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionStatusResponse.Merge(m, src)
}
func (m *PartitionStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *PartitionStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionStatusResponse proto.InternalMessageInfo

func (m *PartitionStatusResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *PartitionStatusResponse) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

type PartitionNotification struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartitionNotification) Reset()         { *m = PartitionNotification{} }
func (m *PartitionNotification) String() string { return proto.CompactTextString(m) }
func (*PartitionNotification) ProtoMessage()    {}
func (*PartitionNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{41}
}
func (m *PartitionNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionNotification.Merge(m, src)
}
func (m *PartitionNotification) XXX_Size() int {
	return m.Size()
}
func (m *PartitionNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionNotification.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionNotification proto.InternalMessageInfo

func (m *PartitionNotification) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *PartitionNotification) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

type Cursor struct {
	Stream               string   `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	Partition            int32    `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
	CursorId             string   `protobuf:"bytes,3,opt,name=cursorId,proto3" json:"cursorId,omitempty"`
	Offset               int64    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cursor) Reset()         { *m = Cursor{} }
func (m *Cursor) String() string { return proto.CompactTextString(m) }
func (*Cursor) ProtoMessage()    {}
func (*Cursor) Descriptor() ([]byte, []int) {
	return fileDescriptor_41f4a519b878ee3b, []int{42}
}
func (m *Cursor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cursor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cursor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cursor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cursor.Merge(m, src)
}
func (m *Cursor) XXX_Size() int {
	return m.Size()
}
func (m *Cursor) XXX_DiscardUnknown() {
	xxx_messageInfo_Cursor.DiscardUnknown(m)
}

var xxx_messageInfo_Cursor proto.InternalMessageInfo

func (m *Cursor) GetStream() string {
	if m != nil {
		return m.Stream
	}
	return ""
}

func (m *Cursor) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *Cursor) GetCursorId() string {
	if m != nil {
		return m.CursorId
	}
	return ""
}

func (m *Cursor) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func init() {
	proto.RegisterEnum("protocol.Op", Op_name, Op_value)
	proto.RegisterType((*ServerState)(nil), "protocol.ServerState")
	proto.RegisterType((*RaftLog)(nil), "protocol.RaftLog")
	proto.RegisterType((*CreateStreamOp)(nil), "protocol.CreateStreamOp")
	proto.RegisterType((*ShrinkISROp)(nil), "protocol.ShrinkISROp")
	proto.RegisterType((*ExpandISROp)(nil), "protocol.ExpandISROp")
	proto.RegisterType((*DeleteStreamOp)(nil), "protocol.DeleteStreamOp")
	proto.RegisterType((*PauseStreamOp)(nil), "protocol.PauseStreamOp")
	proto.RegisterType((*ResumeStreamOp)(nil), "protocol.ResumeStreamOp")
	proto.RegisterType((*ReportLeaderOp)(nil), "protocol.ReportLeaderOp")
	proto.RegisterType((*ChangeLeaderOp)(nil), "protocol.ChangeLeaderOp")
	proto.RegisterType((*ReportConsumerGroupCoordinatorOp)(nil), "protocol.ReportConsumerGroupCoordinatorOp")
	proto.RegisterType((*ChangeConsumerGroupCoordinatorOp)(nil), "protocol.ChangeConsumerGroupCoordinatorOp")
	proto.RegisterType((*PublishActivityOp)(nil), "protocol.PublishActivityOp")
	proto.RegisterType((*SetStreamReadonlyOp)(nil), "protocol.SetStreamReadonlyOp")
	proto.RegisterType((*CreateConsumerGroupOp)(nil), "protocol.CreateConsumerGroupOp")
	proto.RegisterType((*JoinConsumerGroupOp)(nil), "protocol.JoinConsumerGroupOp")
	proto.RegisterType((*LeaveConsumerGroupOp)(nil), "protocol.LeaveConsumerGroupOp")
	proto.RegisterType((*Policy)(nil), "protocol.Policy")
	proto.RegisterType((*AddPolicyOp)(nil), "protocol.AddPolicyOp")
	proto.RegisterType((*RevokePolicyOp)(nil), "protocol.RevokePolicyOp")
	proto.RegisterType((*NullableInt64)(nil), "protocol.NullableInt64")
	proto.RegisterType((*NullableInt32)(nil), "protocol.NullableInt32")
	proto.RegisterType((*NullableBool)(nil), "protocol.NullableBool")
	proto.RegisterType((*StreamConfig)(nil), "protocol.StreamConfig")
	proto.RegisterType((*Stream)(nil), "protocol.Stream")
	proto.RegisterType((*Partition)(nil), "protocol.Partition")
	proto.RegisterType((*Consumer)(nil), "protocol.Consumer")
	proto.RegisterType((*ConsumerGroup)(nil), "protocol.ConsumerGroup")
	proto.RegisterType((*RaftJoinRequest)(nil), "protocol.RaftJoinRequest")
	proto.RegisterType((*RaftJoinResponse)(nil), "protocol.RaftJoinResponse")
	proto.RegisterType((*MetadataSnapshot)(nil), "protocol.MetadataSnapshot")
	proto.RegisterType((*ReplicationRequest)(nil), "protocol.ReplicationRequest")
	proto.RegisterType((*LeaderEpochOffsetRequest)(nil), "protocol.LeaderEpochOffsetRequest")
	proto.RegisterType((*LeaderEpochOffsetResponse)(nil), "protocol.LeaderEpochOffsetResponse")
	proto.RegisterType((*PropagatedRequest)(nil), "protocol.PropagatedRequest")
	proto.RegisterType((*Error)(nil), "protocol.Error")
	proto.RegisterType((*PropagatedResponse)(nil), "protocol.PropagatedResponse")
	proto.RegisterType((*PropagatedResponse_JoinConsumerGroupResponse)(nil), "protocol.PropagatedResponse.JoinConsumerGroupResponse")
	proto.RegisterType((*ServerInfoRequest)(nil), "protocol.ServerInfoRequest")
	proto.RegisterType((*ServerInfoResponse)(nil), "protocol.ServerInfoResponse")
	proto.RegisterType((*PartitionStatusRequest)(nil), "protocol.PartitionStatusRequest")
	proto.RegisterType((*PartitionStatusResponse)(nil), "protocol.PartitionStatusResponse")
	proto.RegisterType((*PartitionNotification)(nil), "protocol.PartitionNotification")
	proto.RegisterType((*Cursor)(nil), "protocol.Cursor")
}

func init() { proto.RegisterFile("internal.proto", fileDescriptor_41f4a519b878ee3b) }

var fileDescriptor_41f4a519b878ee3b = []byte{
	// 2121 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x59, 0x5f, 0x6f, 0x1b, 0x4b,
	0x15, 0xbf, 0xb6, 0xe3, 0x7f, 0xc7, 0xb1, 0xe3, 0x4c, 0x93, 0x5c, 0xb7, 0xf4, 0x86, 0xb0, 0x50,
	0x29, 0x54, 0x97, 0x22, 0xd2, 0xab, 0x5e, 0x81, 0x00, 0xe1, 0xda, 0x4b, 0xbb, 0xb7, 0x8e, 0xd7,
	0x1a, 0x27, 0xd5, 0x2d, 0x42, 0x37, 0xda, 0xec, 0x4e, 0x92, 0xed, 0x5d, 0xef, 0x2c, 0xb3, 0xeb,
	0x28, 0x7d, 0x46, 0x7c, 0x03, 0x1e, 0x00, 0xf1, 0xc2, 0x13, 0x1f, 0x84, 0x17, 0x78, 0x43, 0xe2,
	0x0b, 0xa0, 0xf2, 0xc8, 0x97, 0x40, 0x33, 0x3b, 0xfb, 0xdf, 0x76, 0x54, 0x87, 0x07, 0x24, 0x9e,
	0xbc, 0xe7, 0xcc, 0xef, 0x9c, 0x39, 0x33, 0x73, 0xe6, 0xfc, 0x19, 0x43, 0xc7, 0x76, 0x03, 0xc2,
	0x5c, 0xc3, 0x79, 0xe2, 0x31, 0x1a, 0x50, 0xd4, 0x10, 0x3f, 0x26, 0x75, 0x94, 0xef, 0x42, 0x6b,
	0x4a, 0xd8, 0x35, 0x61, 0xd3, 0xc0, 0x08, 0x08, 0x7a, 0x00, 0x0d, 0x5f, 0x90, 0xda, 0xb0, 0x57,
	0x3a, 0x28, 0x1d, 0x36, 0x71, 0x4c, 0x2b, 0xff, 0x6e, 0x40, 0x1d, 0x1b, 0x17, 0xc1, 0x88, 0x5e,
	0xa2, 0x87, 0x50, 0xa6, 0x9e, 0x40, 0x74, 0x8e, 0x36, 0x9f, 0x44, 0xda, 0x9e, 0xe8, 0x1e, 0x2e,
	0x53, 0x0f, 0xfd, 0x0c, 0x3a, 0x26, 0x23, 0x46, 0x40, 0xa6, 0x01, 0x23, 0xc6, 0x4c, 0xf7, 0x7a,
	0xe5, 0x83, 0xd2, 0x61, 0xeb, 0xa8, 0x97, 0x20, 0x07, 0x99, 0x71, 0x9c, 0xc3, 0xa3, 0xcf, 0xa1,
	0xe5, 0x5f, 0x31, 0xdb, 0xfd, 0x5a, 0x9b, 0x62, 0xdd, 0xeb, 0x55, 0x84, 0xf8, 0x6e, 0x22, 0x3e,
	0x4d, 0x06, 0x71, 0x1a, 0x29, 0xa6, 0xbe, 0x32, 0xdc, 0x4b, 0x32, 0x22, 0x86, 0x45, 0x98, 0xee,
	0xf5, 0x36, 0x0a, 0x53, 0x67, 0xc6, 0x71, 0x0e, 0xcf, 0xa7, 0x26, 0x37, 0x9e, 0xe1, 0x5a, 0xe1,
	0xd4, 0xd5, 0xfc, 0xd4, 0x6a, 0x32, 0x88, 0xd3, 0x48, 0x3e, 0xb5, 0x45, 0x1c, 0x92, 0x5a, 0x75,
	0x2d, 0x3f, 0xf5, 0x30, 0x33, 0x8e, 0x73, 0x78, 0xf4, 0x13, 0x68, 0x7b, 0xc6, 0xdc, 0x4f, 0x14,
	0xd4, 0x85, 0x82, 0x8f, 0x13, 0x05, 0x93, 0xf4, 0x30, 0xce, 0xa2, 0xb9, 0x01, 0x8c, 0xf8, 0xf3,
	0x59, 0x22, 0xdf, 0xc8, 0x1b, 0x80, 0x33, 0xe3, 0x38, 0x87, 0x47, 0x1a, 0x6c, 0x7b, 0xf3, 0x73,
	0xc7, 0xf6, 0xaf, 0xfa, 0x66, 0x60, 0x5f, 0xdb, 0xc1, 0x3b, 0xdd, 0xeb, 0x35, 0x85, 0x92, 0x6f,
	0xa4, 0x8c, 0xc8, 0x43, 0x70, 0x51, 0x0a, 0xe9, 0x70, 0xcf, 0x27, 0x41, 0xa8, 0x19, 0x13, 0xc3,
	0xa2, 0xae, 0xc3, 0x95, 0x81, 0x50, 0xf6, 0x49, 0xea, 0x24, 0x8b, 0x20, 0xbc, 0x48, 0x12, 0x9d,
	0xc2, 0x6e, 0xe8, 0x24, 0x03, 0xea, 0x72, 0xa3, 0xd9, 0x0b, 0x46, 0xe7, 0x9e, 0xee, 0xf5, 0x5a,
	0x42, 0xe5, 0x37, 0xf3, 0xbe, 0x95, 0x83, 0xe1, 0xc5, 0xd2, 0xdc, 0xce, 0xb7, 0xd4, 0x76, 0xf3,
	0x4a, 0x37, 0xf3, 0x76, 0x7e, 0x51, 0x04, 0xe1, 0x45, 0x92, 0x08, 0xc3, 0x8e, 0x43, 0x8c, 0xeb,
	0x82, 0x99, 0x6d, 0xa1, 0x71, 0x3f, 0xd1, 0x38, 0x5a, 0x80, 0xc2, 0x0b, 0x65, 0xd1, 0x35, 0x1c,
	0x84, 0x5e, 0x9a, 0x19, 0x18, 0x50, 0xca, 0x2c, 0xdb, 0x35, 0x02, 0xca, 0xfd, 0xbc, 0x23, 0xf4,
	0x3f, 0xce, 0xfb, 0xf9, 0x72, 0x09, 0x7c, 0xab, 0x4e, 0x7e, 0x17, 0x0c, 0xcb, 0x9a, 0x50, 0xc7,
	0x36, 0xf9, 0xe1, 0x6d, 0xe5, 0xef, 0x42, 0x3f, 0x19, 0xc4, 0x69, 0x64, 0xe8, 0x8a, 0xd7, 0xf4,
	0x6b, 0x12, 0xcb, 0x76, 0x8b, 0xae, 0x98, 0x1e, 0xc7, 0x39, 0xbc, 0xf2, 0x23, 0xe8, 0x64, 0x63,
	0x04, 0x3a, 0x84, 0x9a, 0x2f, 0xbe, 0x45, 0xdc, 0x69, 0x1d, 0x75, 0x53, 0x4e, 0x14, 0x3a, 0x8b,
	0x1c, 0x57, 0xfe, 0x5c, 0x82, 0x56, 0x2a, 0x42, 0xa0, 0xbd, 0x8c, 0x64, 0x33, 0xc2, 0xa1, 0x87,
	0xd0, 0xf4, 0x0c, 0x16, 0xd8, 0x81, 0x4d, 0x5d, 0x11, 0xa2, 0xaa, 0x38, 0x61, 0xa0, 0x43, 0xd8,
	0x62, 0xc4, 0x73, 0x6c, 0xd3, 0x38, 0xa1, 0x98, 0xcc, 0xe8, 0x35, 0x11, 0x71, 0xa8, 0x89, 0xf3,
	0x6c, 0xae, 0xdf, 0x11, 0xe1, 0x43, 0x04, 0x9b, 0x26, 0x96, 0x14, 0x3a, 0x80, 0x56, 0xf8, 0xa5,
	0x7a, 0xd4, 0xbc, 0x12, 0xa1, 0x64, 0x03, 0xa7, 0x59, 0xca, 0x9f, 0x4a, 0xd0, 0x4a, 0x05, 0x94,
	0x35, 0x2d, 0x55, 0x60, 0x33, 0x36, 0xa9, 0x6f, 0x59, 0xd2, 0xcc, 0x0c, 0xef, 0x0e, 0x36, 0x1e,
	0x42, 0x27, 0x1b, 0xb7, 0x96, 0x59, 0xa9, 0x10, 0x68, 0x67, 0x02, 0xd4, 0xd2, 0xe5, 0xec, 0x03,
	0xc4, 0xd6, 0xfb, 0xbd, 0xf2, 0x41, 0xe5, 0xb0, 0x8a, 0x53, 0x1c, 0xbe, 0xdc, 0x30, 0x32, 0xf5,
	0x1d, 0x47, 0xac, 0xa6, 0x81, 0x13, 0x86, 0xf2, 0x12, 0x3a, 0xd9, 0x38, 0xb6, 0xee, 0x3c, 0xca,
	0x1f, 0x4a, 0x5c, 0x95, 0x47, 0x59, 0x10, 0x87, 0xff, 0xf5, 0x4e, 0xa0, 0x07, 0x75, 0xb9, 0xdb,
	0x72, 0xf3, 0x23, 0xf2, 0x0e, 0xfb, 0xfe, 0x15, 0x74, 0xb2, 0xa9, 0x6a, 0x4d, 0xdb, 0x12, 0x0b,
	0x2a, 0x69, 0x0b, 0x94, 0xdf, 0x96, 0xe0, 0x20, 0x5c, 0xfc, 0x8a, 0x08, 0xd0, 0x83, 0xfa, 0x25,
	0xe7, 0x6a, 0x96, 0x9c, 0x33, 0x22, 0xf9, 0xde, 0x9a, 0x52, 0x4e, 0xb3, 0xc4, 0xac, 0x4d, 0x9c,
	0xe2, 0xf0, 0x05, 0x9a, 0x89, 0x2a, 0x39, 0x77, 0x9a, 0x85, 0x76, 0xa0, 0x4a, 0xc4, 0xe2, 0x37,
	0xc4, 0xe2, 0x43, 0x42, 0xf9, 0x0a, 0x0e, 0x6e, 0x8b, 0x5c, 0x2b, 0xac, 0xca, 0xcd, 0x5a, 0x2e,
	0xcc, 0xaa, 0xfc, 0x00, 0xb6, 0x0b, 0x09, 0x4c, 0x38, 0x9c, 0x71, 0x11, 0x68, 0xae, 0x45, 0x6e,
	0x84, 0xca, 0x0d, 0x9c, 0x30, 0x14, 0x1b, 0xee, 0x2d, 0x48, 0x53, 0x6b, 0x7b, 0xf7, 0x03, 0x68,
	0x30, 0xa9, 0x45, 0x3a, 0x77, 0x4c, 0x2b, 0xaf, 0x61, 0x77, 0x61, 0xfa, 0xe2, 0xb5, 0x81, 0x99,
	0x66, 0xc9, 0x20, 0x98, 0xaa, 0x0d, 0x32, 0x12, 0x38, 0x8b, 0xe6, 0x4b, 0x58, 0x90, 0xc1, 0xee,
	0x70, 0xbc, 0x3d, 0xa8, 0x87, 0xcb, 0xf5, 0x7b, 0x95, 0x83, 0x0a, 0x97, 0x94, 0xa4, 0xf2, 0x16,
	0x76, 0x16, 0xa5, 0xb6, 0xbb, 0xcd, 0x45, 0x6e, 0x3c, 0x9b, 0x11, 0x4b, 0xee, 0x57, 0x44, 0x2a,
	0x5f, 0x42, 0x2d, 0xcc, 0x18, 0xfc, 0x30, 0xe6, 0xbe, 0x90, 0x97, 0x87, 0x11, 0x52, 0x5c, 0x37,
	0x23, 0x3e, 0x9d, 0x33, 0x93, 0x24, 0xba, 0x13, 0x0e, 0x97, 0x33, 0x4c, 0x71, 0x71, 0xe4, 0xed,
	0x08, 0x29, 0xe5, 0x73, 0x68, 0xa5, 0xb2, 0x1b, 0x4f, 0x3e, 0x9e, 0xf8, 0x2e, 0x26, 0x9f, 0x10,
	0x83, 0xe5, 0x38, 0x4f, 0x5c, 0xd9, 0xd4, 0xf6, 0x01, 0xb2, 0x8f, 0xa0, 0x3d, 0x9e, 0x3b, 0x8e,
	0x71, 0xee, 0x10, 0xcd, 0x0d, 0x9e, 0x7d, 0xc6, 0xaf, 0xc8, 0xb5, 0xe1, 0xcc, 0x89, 0x90, 0xac,
	0xe0, 0x90, 0xc8, 0xc1, 0x9e, 0x1e, 0x65, 0x61, 0xd5, 0x08, 0xf6, 0x1d, 0xd8, 0x8c, 0x60, 0xcf,
	0x29, 0x75, 0xb2, 0xa8, 0x46, 0x84, 0xfa, 0x7d, 0x1d, 0x36, 0x43, 0xd7, 0x1e, 0x50, 0xf7, 0xc2,
	0xbe, 0x44, 0x2a, 0x6c, 0x33, 0x12, 0x10, 0x97, 0x6f, 0xc3, 0xb1, 0x71, 0xf3, 0xfc, 0x5d, 0x40,
	0xfc, 0xa2, 0xb7, 0x65, 0xec, 0xc4, 0x45, 0x09, 0xf4, 0x0a, 0x76, 0xd2, 0xcc, 0x63, 0xe2, 0xfb,
	0xc6, 0x25, 0xf1, 0x65, 0x2b, 0xb0, 0x54, 0xd3, 0x42, 0x21, 0xd4, 0xe7, 0xb9, 0x38, 0xe1, 0xf7,
	0x2f, 0x89, 0xec, 0x09, 0x96, 0xea, 0xc9, 0xe3, 0xb9, 0x0a, 0xd3, 0x21, 0x86, 0x4b, 0x98, 0xc6,
	0x9b, 0xa1, 0x6b, 0xc3, 0x91, 0xad, 0xc1, 0x72, 0x15, 0x39, 0x3c, 0x57, 0xe1, 0x93, 0xcb, 0x19,
	0x71, 0x83, 0x78, 0x5f, 0xaa, 0xb7, 0xa8, 0xc8, 0xe1, 0xf9, 0x35, 0x4e, 0x58, 0x7c, 0x19, 0xb5,
	0xd5, 0x0a, 0xb2, 0x68, 0xbe, 0xa9, 0x26, 0x9d, 0x79, 0x86, 0xc9, 0x19, 0x2f, 0x28, 0xa3, 0xf3,
	0xc0, 0x76, 0x89, 0x5f, 0x6c, 0x14, 0x32, 0xfe, 0x81, 0x17, 0x0a, 0xa1, 0x9f, 0x42, 0x47, 0xf2,
	0x55, 0x97, 0x63, 0x2d, 0xd9, 0x2f, 0xec, 0x15, 0xd5, 0x70, 0xff, 0xc1, 0x39, 0x34, 0x5f, 0x8b,
	0x31, 0x0f, 0xa8, 0x48, 0xf9, 0x27, 0xf6, 0x8c, 0xc8, 0x4e, 0x61, 0xf9, 0x5a, 0x32, 0x68, 0xf4,
	0x4b, 0xf8, 0x24, 0x66, 0x0c, 0x6d, 0x5f, 0xe0, 0x2e, 0xa6, 0xf3, 0x73, 0xdf, 0x64, 0xf6, 0x39,
	0x61, 0xbe, 0xec, 0x15, 0x96, 0x59, 0xb3, 0x5a, 0x18, 0x7d, 0x1f, 0x6a, 0x33, 0xdb, 0xd5, 0x7c,
	0x26, 0xfb, 0x83, 0xa5, 0x7b, 0x23, 0x61, 0xe8, 0x17, 0xf0, 0x90, 0x7a, 0x81, 0x3d, 0xb3, 0xfd,
	0xc0, 0x36, 0x07, 0xd4, 0x35, 0xe7, 0x8c, 0x11, 0xd7, 0x7c, 0x37, 0xa0, 0x6e, 0xc0, 0xa8, 0x23,
	0x3b, 0x82, 0x65, 0xd6, 0xac, 0x94, 0x45, 0xcf, 0x00, 0x88, 0x6b, 0xb2, 0x77, 0x9e, 0x08, 0x34,
	0xed, 0x95, 0x9a, 0x52, 0x48, 0xe5, 0x6f, 0x25, 0xa8, 0x85, 0x77, 0x13, 0x21, 0xd8, 0x70, 0x8d,
	0x19, 0x91, 0xd1, 0x4d, 0x7c, 0x8b, 0x18, 0x3c, 0x3f, 0x7f, 0x4b, 0xcc, 0x40, 0x06, 0xb6, 0x88,
	0x44, 0x4f, 0x33, 0x29, 0x88, 0x07, 0xe8, 0xd6, 0xd1, 0xbd, 0x74, 0x1b, 0x29, 0xc7, 0x32, 0x79,
	0xe9, 0x09, 0xd4, 0x4c, 0x11, 0x02, 0xe4, 0xc5, 0xd8, 0xcb, 0x17, 0xd8, 0x61, 0x80, 0xc0, 0x12,
	0x85, 0x3e, 0x85, 0x6d, 0xd1, 0x53, 0xd9, 0xd4, 0xe5, 0x07, 0xea, 0x07, 0xc6, 0x2c, 0xec, 0x97,
	0x2b, 0xb8, 0x38, 0xa0, 0xfc, 0xa5, 0x0c, 0xcd, 0x49, 0xba, 0x60, 0x8a, 0x4c, 0x2f, 0x65, 0x4d,
	0x4f, 0xb2, 0x6a, 0x39, 0x93, 0x55, 0x3b, 0x50, 0xb6, 0xc3, 0xf8, 0x5f, 0xc5, 0x65, 0xdb, 0xe2,
	0xd1, 0x4c, 0xe4, 0x0f, 0x59, 0x57, 0x85, 0x04, 0xb7, 0x49, 0x56, 0x5e, 0x7c, 0x9a, 0x9f, 0x1b,
	0x26, 0xaf, 0x02, 0xaa, 0x42, 0xa8, 0x38, 0x10, 0x66, 0x62, 0xc1, 0xf4, 0x7b, 0x35, 0x91, 0xc5,
	0x62, 0x3a, 0x55, 0x36, 0xd5, 0x33, 0x85, 0x5b, 0x17, 0x2a, 0xb6, 0xcf, 0x7a, 0x0d, 0x01, 0xe7,
	0x9f, 0xf9, 0x52, 0xae, 0x59, 0x28, 0xe5, 0x92, 0x4a, 0x07, 0x52, 0x95, 0x0e, 0x9f, 0x41, 0x34,
	0xf0, 0x96, 0x70, 0xd1, 0x06, 0x96, 0x54, 0xa6, 0x3e, 0xd8, 0xcc, 0xd5, 0x07, 0x9f, 0x41, 0x23,
	0xca, 0xab, 0x72, 0x47, 0xc2, 0xed, 0xe3, 0x3b, 0x92, 0x4a, 0xc9, 0xe5, 0x6c, 0x4a, 0xfe, 0x4d,
	0x09, 0xda, 0x99, 0x74, 0x5c, 0x90, 0xfd, 0x14, 0xea, 0x33, 0x32, 0x13, 0xd7, 0xae, 0x2c, 0xbc,
	0x05, 0x15, 0x0b, 0x0b, 0x1c, 0x41, 0xd6, 0xae, 0xed, 0x54, 0xd8, 0xc2, 0xc6, 0x45, 0xc0, 0x2b,
	0x11, 0x4c, 0x7e, 0x35, 0x27, 0xbe, 0x38, 0x6e, 0x97, 0x5a, 0x24, 0x7e, 0x6f, 0x92, 0x14, 0xdf,
	0x04, 0xfe, 0xd5, 0xb7, 0xac, 0xa8, 0x8a, 0x8b, 0x69, 0xe5, 0x10, 0xba, 0x89, 0x1a, 0xdf, 0xa3,
	0xae, 0x4f, 0xc4, 0x84, 0x8c, 0x51, 0x26, 0xd5, 0x84, 0x84, 0x42, 0xa1, 0x7b, 0x4c, 0x02, 0xc3,
	0x32, 0x02, 0x63, 0xea, 0x1a, 0x9e, 0x7f, 0x45, 0x03, 0xf4, 0x38, 0xd9, 0xa6, 0x92, 0x58, 0x6a,
	0xb1, 0x91, 0x8c, 0x00, 0x3c, 0x8a, 0x08, 0xbf, 0x8a, 0x76, 0x65, 0x69, 0xb9, 0x25, 0x61, 0x8a,
	0x03, 0x08, 0x27, 0x6e, 0x16, 0x2d, 0x52, 0xf4, 0x33, 0x82, 0x1b, 0xaf, 0x33, 0x61, 0xf0, 0x2d,
	0xa0, 0x17, 0x17, 0x3e, 0x09, 0x6f, 0x71, 0x05, 0x4b, 0x2a, 0xef, 0x57, 0x95, 0x62, 0x8b, 0xf0,
	0x63, 0xe8, 0x8d, 0x12, 0x52, 0x17, 0x62, 0xd1, 0x9c, 0x39, 0xe9, 0x52, 0x51, 0xfa, 0x87, 0x70,
	0x7f, 0x81, 0xb4, 0xdc, 0xcf, 0x87, 0xd0, 0x24, 0xae, 0x15, 0x32, 0x65, 0xf5, 0x91, 0x30, 0x94,
	0x7f, 0xd4, 0x61, 0x7b, 0xc2, 0xa8, 0x67, 0x5c, 0x1a, 0x01, 0xb1, 0x92, 0x65, 0xfe, 0xef, 0xbe,
	0x0a, 0xb2, 0x4c, 0x9b, 0x57, 0x7c, 0x15, 0xcc, 0xb6, 0x81, 0x38, 0x87, 0xff, 0xbf, 0x7e, 0x15,
	0x5c, 0xf2, 0x94, 0xd7, 0x5c, 0xfb, 0x29, 0x6f, 0xc9, 0x9b, 0x1b, 0xfc, 0xd7, 0xdf, 0xdc, 0x5a,
	0x77, 0x7b, 0x73, 0x63, 0xb7, 0x74, 0xc7, 0xb2, 0x26, 0x78, 0x9c, 0xf7, 0xa2, 0x55, 0x6f, 0x6e,
	0xb7, 0xe9, 0xcc, 0xbf, 0xb9, 0xb5, 0xef, 0xf0, 0xe6, 0xd6, 0xf9, 0xc0, 0x37, 0xb7, 0xef, 0x41,
	0x55, 0xe5, 0x61, 0x93, 0x17, 0x1b, 0x26, 0xb5, 0xc2, 0x62, 0xa3, 0x8d, 0xc5, 0x37, 0xcf, 0x7b,
	0x33, 0xff, 0x52, 0xc6, 0x62, 0xfe, 0xa9, 0xfc, 0xb1, 0x0c, 0x28, 0x1d, 0x04, 0xe2, 0xc8, 0xb1,
	0x2a, 0x0a, 0x3c, 0x8a, 0xe2, 0x74, 0x78, 0xf9, 0xb7, 0x52, 0x57, 0x88, 0xb3, 0x65, 0xe0, 0x46,
	0x0e, 0xec, 0x16, 0x0e, 0x9a, 0xcf, 0x20, 0x8f, 0xf4, 0x59, 0xca, 0xf9, 0x0b, 0x16, 0x14, 0xfd,
	0x26, 0x1a, 0xc1, 0x8b, 0x95, 0x3e, 0x98, 0xc2, 0xfd, 0xa5, 0x32, 0xf9, 0x64, 0x57, 0x5a, 0x91,
	0xec, 0xca, 0xe9, 0x64, 0xf7, 0x6d, 0xd8, 0x0e, 0xff, 0x5a, 0xd1, 0xdc, 0x0b, 0x1a, 0x85, 0xc8,
	0x5c, 0xde, 0x55, 0x46, 0x80, 0xd2, 0x20, 0x39, 0x65, 0x3e, 0x3b, 0x23, 0xd8, 0xb8, 0xa2, 0x7e,
	0x54, 0xe5, 0x89, 0x6f, 0xce, 0xe3, 0x9e, 0x24, 0x2b, 0x22, 0xf1, 0xad, 0x8c, 0x61, 0x2f, 0x2e,
	0xb1, 0xa6, 0x81, 0x11, 0xcc, 0xfd, 0x54, 0x9a, 0xfd, 0xf0, 0xa7, 0x23, 0xe5, 0x18, 0x3e, 0x2e,
	0xe8, 0x93, 0x26, 0xee, 0x41, 0x8d, 0xdc, 0xd8, 0x7e, 0xe0, 0xcb, 0x6e, 0x52, 0x52, 0x3c, 0x6f,
	0xdb, 0x7e, 0x18, 0x36, 0x85, 0xbe, 0x06, 0x8e, 0x69, 0xe5, 0x18, 0x76, 0x63, 0x75, 0x63, 0x1a,
	0xd8, 0x17, 0x32, 0x4d, 0xae, 0x69, 0x1d, 0x83, 0xda, 0x60, 0xce, 0x7c, 0xca, 0xd6, 0x7c, 0x18,
	0x7b, 0x00, 0x0d, 0x53, 0xc8, 0x6b, 0xd1, 0x93, 0x69, 0x4c, 0xa7, 0x72, 0xf2, 0x46, 0x3a, 0x27,
	0x3f, 0xfe, 0x75, 0x05, 0xca, 0xba, 0x87, 0xb6, 0xa1, 0x3d, 0xc0, 0x6a, 0xff, 0x44, 0x3d, 0x9b,
	0x9e, 0x60, 0xb5, 0x7f, 0xdc, 0xfd, 0x08, 0x75, 0x00, 0xa6, 0x2f, 0xb1, 0x36, 0x7e, 0x75, 0xa6,
	0x4d, 0x71, 0xb7, 0xc4, 0x21, 0x58, 0x9d, 0xe8, 0xf8, 0xe4, 0x6c, 0xa4, 0xf6, 0x87, 0x2a, 0xee,
	0x96, 0x85, 0xd4, 0xcb, 0xfe, 0xf8, 0x85, 0x1a, 0xb1, 0x2a, 0x5c, 0x4a, 0xfd, 0x72, 0xd2, 0x1f,
	0x0f, 0x85, 0xd4, 0x06, 0x87, 0x0c, 0xd5, 0x91, 0x9a, 0x28, 0xae, 0xa2, 0x2e, 0x6c, 0x4e, 0xfa,
	0xa7, 0xd3, 0x98, 0x53, 0x0b, 0x55, 0x4f, 0x4f, 0x8f, 0x63, 0x56, 0x1d, 0xed, 0x40, 0x77, 0x72,
	0xfa, 0x7c, 0xa4, 0x4d, 0x5f, 0x9e, 0xf5, 0x07, 0x27, 0xda, 0x6b, 0xed, 0xe4, 0x4d, 0xb7, 0x81,
	0x3e, 0x86, 0x7b, 0x53, 0xf5, 0x44, 0xa2, 0xce, 0xb0, 0xda, 0x1f, 0xea, 0xe3, 0xd1, 0x9b, 0x6e,
	0x13, 0xdd, 0x87, 0x5d, 0x69, 0xff, 0x40, 0x1f, 0x73, 0x4d, 0xf8, 0xec, 0x05, 0xd6, 0x4f, 0x27,
	0x5d, 0xe0, 0x32, 0x5f, 0xe8, 0xda, 0x38, 0x3f, 0xd0, 0x42, 0x3d, 0xd8, 0x19, 0xa9, 0xfd, 0xd7,
	0x05, 0x91, 0x4d, 0xf4, 0x08, 0xbe, 0x25, 0x97, 0x9a, 0x1d, 0x3a, 0x1b, 0xe8, 0x3a, 0x1e, 0x6a,
	0xe3, 0xfe, 0x89, 0x8e, 0xbb, 0x6d, 0x0e, 0x93, 0xcb, 0x5f, 0x01, 0xeb, 0xf0, 0x2d, 0xe9, 0x0f,
	0x87, 0x67, 0x13, 0x7d, 0xa4, 0x0d, 0xde, 0x74, 0xb7, 0xc2, 0xd5, 0xbe, 0xd6, 0x5f, 0xa9, 0x11,
	0xab, 0xfb, 0xbc, 0xfb, 0xd7, 0xf7, 0xfb, 0xa5, 0xbf, 0xbf, 0xdf, 0x2f, 0xfd, 0xf3, 0xfd, 0x7e,
	0xe9, 0x77, 0xff, 0xda, 0xff, 0xe8, 0xbc, 0x26, 0xe2, 0xc1, 0xd3, 0xff, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x2b, 0xcf, 0x65, 0x0e, 0xea, 0x1c, 0x00, 0x00,
}

func (m *ServerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RevokePolicyOp != nil {
		{
			size, err := m.RevokePolicyOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.AddPolicyOp != nil {
		{
			size, err := m.AddPolicyOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ChangeConsumerGroupCoordinatorOp != nil {
		{
			size, err := m.ChangeConsumerGroupCoordinatorOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.LeaveConsumerGroupOp != nil {
		{
			size, err := m.LeaveConsumerGroupOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.JoinConsumerGroupOp != nil {
		{
			size, err := m.JoinConsumerGroupOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.CreateConsumerGroupOp != nil {
		{
			size, err := m.CreateConsumerGroupOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SetStreamReadonlyOp != nil {
		{
			size, err := m.SetStreamReadonlyOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.PublishActivityOp != nil {
		{
			size, err := m.PublishActivityOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ResumeStreamOp != nil {
		{
			size, err := m.ResumeStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PauseStreamOp != nil {
		{
			size, err := m.PauseStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DeleteStreamOp != nil {
		{
			size, err := m.DeleteStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ExpandISROp != nil {
		{
			size, err := m.ExpandISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ChangeLeaderOp != nil {
		{
			size, err := m.ChangeLeaderOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ShrinkISROp != nil {
		{
			size, err := m.ShrinkISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreateStreamOp != nil {
		{
			size, err := m.CreateStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStreamOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateStreamOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stream != nil {
		{
			size, err := m.Stream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShrinkISROp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShrinkISROp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShrinkISROp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReplicaToRemove) > 0 {
		i -= len(m.ReplicaToRemove)
		copy(dAtA[i:], m.ReplicaToRemove)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaToRemove)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExpandISROp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpandISROp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExpandISROp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReplicaToAdd) > 0 {
		i -= len(m.ReplicaToAdd)
		copy(dAtA[i:], m.ReplicaToAdd)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaToAdd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStreamOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteStreamOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PauseStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauseStreamOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PauseStreamOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResumeAll {
		i--
		if m.ResumeAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Partitions) > 0 {
		dAtA18 := make([]byte, len(m.Partitions)*10)
		var j17 int
		for _, num1 := range m.Partitions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintInternal(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResumeStreamOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumeStreamOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResumeStreamOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Partitions) > 0 {
		dAtA20 := make([]byte, len(m.Partitions)*10)
		var j19 int
		for _, num1 := range m.Partitions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintInternal(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportLeaderOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportLeaderOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportLeaderOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Replica) > 0 {
		i -= len(m.Replica)
		copy(dAtA[i:], m.Replica)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Replica)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeLeaderOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeLeaderOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeLeaderOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportConsumerGroupCoordinatorOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportConsumerGroupCoordinatorOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportConsumerGroupCoordinatorOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConsumerId) > 0 {
		i -= len(m.ConsumerId)
		copy(dAtA[i:], m.ConsumerId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ConsumerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeConsumerGroupCoordinatorOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeConsumerGroupCoordinatorOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeConsumerGroupCoordinatorOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishActivityOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishActivityOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishActivityOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RaftIndex != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.RaftIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetStreamReadonlyOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetStreamReadonlyOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetStreamReadonlyOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Readonly {
		i--
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Partitions) > 0 {
		dAtA22 := make([]byte, len(m.Partitions)*10)
		var j21 int
		for _, num1 := range m.Partitions {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintInternal(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateConsumerGroupOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateConsumerGroupOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateConsumerGroupOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConsumerGroup != nil {
		{
			size, err := m.ConsumerGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JoinConsumerGroupOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinConsumerGroupOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JoinConsumerGroupOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Streams[iNdEx])
			copy(dAtA[i:], m.Streams[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Streams[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ConsumerId) > 0 {
		i -= len(m.ConsumerId)
		copy(dAtA[i:], m.ConsumerId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ConsumerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeaveConsumerGroupOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveConsumerGroupOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaveConsumerGroupOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expired {
		i--
		if m.Expired {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ConsumerId) > 0 {
		i -= len(m.ConsumerId)
		copy(dAtA[i:], m.ConsumerId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ConsumerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceId) > 0 {
		i -= len(m.ResourceId)
		copy(dAtA[i:], m.ResourceId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ResourceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddPolicyOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPolicyOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPolicyOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RevokePolicyOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevokePolicyOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevokePolicyOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NullableInt64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableInt64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullableInt64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NullableInt32) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableInt32) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullableInt32) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NullableBool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableBool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullableBool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value {
		i--
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Encryption != nil {
		{
			size, err := m.Encryption.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.OptimisticConcurrencyControl != nil {
		{
			size, err := m.OptimisticConcurrencyControl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.MinIsr != nil {
		{
			size, err := m.MinIsr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.AutoPauseDisableIfSubscribers != nil {
		{
			size, err := m.AutoPauseDisableIfSubscribers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.AutoPauseTime != nil {
		{
			size, err := m.AutoPauseTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CompactEnabled != nil {
		{
			size, err := m.CompactEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CompactMaxGoroutines != nil {
		{
			size, err := m.CompactMaxGoroutines.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SegmentMaxAge != nil {
		{
			size, err := m.SegmentMaxAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.SegmentMaxBytes != nil {
		{
			size, err := m.SegmentMaxBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CleanerInterval != nil {
		{
			size, err := m.CleanerInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RetentionMaxAge != nil {
		{
			size, err := m.RetentionMaxAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.RetentionMaxMessages != nil {
		{
			size, err := m.RetentionMaxMessages.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RetentionMaxBytes != nil {
		{
			size, err := m.RetentionMaxBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Stream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreationTimestamp != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.CreationTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInternal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Partition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Partition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Partition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Readonly {
		i--
		if m.Readonly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Epoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x50
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Isr) > 0 {
		for iNdEx := len(m.Isr) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Isr[iNdEx])
			copy(dAtA[i:], m.Isr[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Isr[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Replicas[iNdEx])
			copy(dAtA[i:], m.Replicas[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Replicas[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Consumer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Consumer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Consumer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Streams[iNdEx])
			copy(dAtA[i:], m.Streams[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Streams[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsumerGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumerGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsumerGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInternal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftJoinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftJoinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftJoinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftJoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftJoinResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftJoinResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetadataSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Groups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInternal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Streams) > 0 {
		for iNdEx := len(m.Streams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Streams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInternal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplicationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x18
	}
	if m.Offset != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ReplicaID) > 0 {
		i -= len(m.ReplicaID)
		copy(dAtA[i:], m.ReplicaID)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ReplicaID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeaderEpochOffsetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderEpochOffsetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderEpochOffsetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LeaderEpoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.LeaderEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LeaderEpochOffsetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaderEpochOffsetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaderEpochOffsetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndOffset != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.EndOffset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropagatedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropagatedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RevokePolicyOp != nil {
		{
			size, err := m.RevokePolicyOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.AddPolicyOp != nil {
		{
			size, err := m.AddPolicyOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ReportConsumerGroupCoordinatorOp != nil {
		{
			size, err := m.ReportConsumerGroupCoordinatorOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.LeaveConsumerGroupOp != nil {
		{
			size, err := m.LeaveConsumerGroupOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.JoinConsumerGroupOp != nil {
		{
			size, err := m.JoinConsumerGroupOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SetStreamReadonlyOp != nil {
		{
			size, err := m.SetStreamReadonlyOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ResumeStreamOp != nil {
		{
			size, err := m.ResumeStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.PauseStreamOp != nil {
		{
			size, err := m.PauseStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DeleteStreamOp != nil {
		{
			size, err := m.DeleteStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ExpandISROp != nil {
		{
			size, err := m.ExpandISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ReportLeaderOp != nil {
		{
			size, err := m.ReportLeaderOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ShrinkISROp != nil {
		{
			size, err := m.ShrinkISROp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CreateStreamOp != nil {
		{
			size, err := m.CreateStreamOp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropagatedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropagatedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.JoinConsumerGroupResp != nil {
		{
			size, err := m.JoinConsumerGroupResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PropagatedResponse_JoinConsumerGroupResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropagatedResponse_JoinConsumerGroupResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropagatedResponse_JoinConsumerGroupResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Epoch != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Coordinator) > 0 {
		i -= len(m.Coordinator)
		copy(dAtA[i:], m.Coordinator)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Coordinator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Port != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsLeader {
		i--
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Exists {
		i--
		if m.Exists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartitionNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionNotification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionNotification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cursor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cursor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cursor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Offset != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CursorId) > 0 {
		i -= len(m.CursorId)
		copy(dAtA[i:], m.CursorId)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.CursorId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Partition != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Stream) > 0 {
		i -= len(m.Stream)
		copy(dAtA[i:], m.Stream)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Stream)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintInternal(dAtA []byte, offset int, v uint64) int {
	offset -= sovInternal(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServerState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.CreateStreamOp != nil {
		l = m.CreateStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ShrinkISROp != nil {
		l = m.ShrinkISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ChangeLeaderOp != nil {
		l = m.ChangeLeaderOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ExpandISROp != nil {
		l = m.ExpandISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteStreamOp != nil {
		l = m.DeleteStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PauseStreamOp != nil {
		l = m.PauseStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResumeStreamOp != nil {
		l = m.ResumeStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PublishActivityOp != nil {
		l = m.PublishActivityOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SetStreamReadonlyOp != nil {
		l = m.SetStreamReadonlyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CreateConsumerGroupOp != nil {
		l = m.CreateConsumerGroupOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.JoinConsumerGroupOp != nil {
		l = m.JoinConsumerGroupOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaveConsumerGroupOp != nil {
		l = m.LeaveConsumerGroupOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ChangeConsumerGroupCoordinatorOp != nil {
		l = m.ChangeConsumerGroupCoordinatorOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.AddPolicyOp != nil {
		l = m.AddPolicyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RevokePolicyOp != nil {
		l = m.RevokePolicyOp.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stream != nil {
		l = m.Stream.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShrinkISROp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.ReplicaToRemove)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExpandISROp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.ReplicaToAdd)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PauseStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		l = 0
		for _, e := range m.Partitions {
			l += sovInternal(uint64(e))
		}
		n += 1 + sovInternal(uint64(l)) + l
	}
	if m.ResumeAll {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResumeStreamOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		l = 0
		for _, e := range m.Partitions {
			l += sovInternal(uint64(e))
		}
		n += 1 + sovInternal(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportLeaderOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.Replica)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeLeaderOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportConsumerGroupCoordinatorOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.ConsumerId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovInternal(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeConsumerGroupCoordinatorOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublishActivityOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftIndex != 0 {
		n += 1 + sovInternal(uint64(m.RaftIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetStreamReadonlyOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		l = 0
		for _, e := range m.Partitions {
			l += sovInternal(uint64(e))
		}
		n += 1 + sovInternal(uint64(l)) + l
	}
	if m.Readonly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateConsumerGroupOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConsumerGroup != nil {
		l = m.ConsumerGroup.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JoinConsumerGroupOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.ConsumerId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Streams) > 0 {
		for _, s := range m.Streams {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaveConsumerGroupOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.ConsumerId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Expired {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.ResourceId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddPolicyOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RevokePolicyOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableInt64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovInternal(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableInt32) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovInternal(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableBool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StreamConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetentionMaxBytes != nil {
		l = m.RetentionMaxBytes.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RetentionMaxMessages != nil {
		l = m.RetentionMaxMessages.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RetentionMaxAge != nil {
		l = m.RetentionMaxAge.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CleanerInterval != nil {
		l = m.CleanerInterval.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SegmentMaxBytes != nil {
		l = m.SegmentMaxBytes.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SegmentMaxAge != nil {
		l = m.SegmentMaxAge.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CompactMaxGoroutines != nil {
		l = m.CompactMaxGoroutines.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CompactEnabled != nil {
		l = m.CompactEnabled.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.AutoPauseTime != nil {
		l = m.AutoPauseTime.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.AutoPauseDisableIfSubscribers != nil {
		l = m.AutoPauseDisableIfSubscribers.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.MinIsr != nil {
		l = m.MinIsr.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.OptimisticConcurrencyControl != nil {
		l = m.OptimisticConcurrencyControl.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Encryption != nil {
		l = m.Encryption.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.CreationTimestamp != 0 {
		n += 1 + sovInternal(uint64(m.CreationTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Partition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovInternal(uint64(m.ReplicationFactor))
	}
	if len(m.Replicas) > 0 {
		for _, s := range m.Replicas {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Isr) > 0 {
		for _, s := range m.Isr {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.Epoch != 0 {
		n += 1 + sovInternal(uint64(m.Epoch))
	}
	if m.Paused {
		n += 2
	}
	if m.Readonly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Consumer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Streams) > 0 {
		for _, s := range m.Streams {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConsumerGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovInternal(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftJoinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftJoinResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetadataSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Streams) > 0 {
		for _, e := range m.Streams {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplicaID)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovInternal(uint64(m.Offset))
	}
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderEpochOffsetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaderEpoch != 0 {
		n += 1 + sovInternal(uint64(m.LeaderEpoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaderEpochOffsetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EndOffset != 0 {
		n += 1 + sovInternal(uint64(m.EndOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.CreateStreamOp != nil {
		l = m.CreateStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ShrinkISROp != nil {
		l = m.ShrinkISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReportLeaderOp != nil {
		l = m.ReportLeaderOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ExpandISROp != nil {
		l = m.ExpandISROp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteStreamOp != nil {
		l = m.DeleteStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PauseStreamOp != nil {
		l = m.PauseStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResumeStreamOp != nil {
		l = m.ResumeStreamOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.SetStreamReadonlyOp != nil {
		l = m.SetStreamReadonlyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.JoinConsumerGroupOp != nil {
		l = m.JoinConsumerGroupOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaveConsumerGroupOp != nil {
		l = m.LeaveConsumerGroupOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReportConsumerGroupCoordinatorOp != nil {
		l = m.ReportConsumerGroupCoordinatorOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.AddPolicyOp != nil {
		l = m.AddPolicyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RevokePolicyOp != nil {
		l = m.RevokePolicyOp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovInternal(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovInternal(uint64(m.Op))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.JoinConsumerGroupResp != nil {
		l = m.JoinConsumerGroupResp.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PropagatedResponse_JoinConsumerGroupResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Coordinator)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovInternal(uint64(m.Epoch))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovInternal(uint64(m.Port))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	if m.IsLeader {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PartitionNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cursor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Stream)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovInternal(uint64(m.Partition))
	}
	l = len(m.CursorId)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovInternal(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInternal(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateStreamOp == nil {
				m.CreateStreamOp = &CreateStreamOp{}
			}
			if err := m.CreateStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkISROp == nil {
				m.ShrinkISROp = &ShrinkISROp{}
			}
			if err := m.ShrinkISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeLeaderOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeLeaderOp == nil {
				m.ChangeLeaderOp = &ChangeLeaderOp{}
			}
			if err := m.ChangeLeaderOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpandISROp == nil {
				m.ExpandISROp = &ExpandISROp{}
			}
			if err := m.ExpandISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteStreamOp == nil {
				m.DeleteStreamOp = &DeleteStreamOp{}
			}
			if err := m.DeleteStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PauseStreamOp == nil {
				m.PauseStreamOp = &PauseStreamOp{}
			}
			if err := m.PauseStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumeStreamOp == nil {
				m.ResumeStreamOp = &ResumeStreamOp{}
			}
			if err := m.ResumeStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishActivityOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublishActivityOp == nil {
				m.PublishActivityOp = &PublishActivityOp{}
			}
			if err := m.PublishActivityOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetStreamReadonlyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetStreamReadonlyOp == nil {
				m.SetStreamReadonlyOp = &SetStreamReadonlyOp{}
			}
			if err := m.SetStreamReadonlyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateConsumerGroupOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateConsumerGroupOp == nil {
				m.CreateConsumerGroupOp = &CreateConsumerGroupOp{}
			}
			if err := m.CreateConsumerGroupOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinConsumerGroupOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinConsumerGroupOp == nil {
				m.JoinConsumerGroupOp = &JoinConsumerGroupOp{}
			}
			if err := m.JoinConsumerGroupOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveConsumerGroupOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeaveConsumerGroupOp == nil {
				m.LeaveConsumerGroupOp = &LeaveConsumerGroupOp{}
			}
			if err := m.LeaveConsumerGroupOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeConsumerGroupCoordinatorOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeConsumerGroupCoordinatorOp == nil {
				m.ChangeConsumerGroupCoordinatorOp = &ChangeConsumerGroupCoordinatorOp{}
			}
			if err := m.ChangeConsumerGroupCoordinatorOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPolicyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddPolicyOp == nil {
				m.AddPolicyOp = &AddPolicyOp{}
			}
			if err := m.AddPolicyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokePolicyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RevokePolicyOp == nil {
				m.RevokePolicyOp = &RevokePolicyOp{}
			}
			if err := m.RevokePolicyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stream == nil {
				m.Stream = &Stream{}
			}
			if err := m.Stream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShrinkISROp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShrinkISROp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShrinkISROp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaToRemove", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaToRemove = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpandISROp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpandISROp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpandISROp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaToAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaToAdd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauseStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PauseStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PauseStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Partitions = append(m.Partitions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Partitions) == 0 {
					m.Partitions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Partitions = append(m.Partitions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResumeAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumeStreamOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumeStreamOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumeStreamOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Partitions = append(m.Partitions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Partitions) == 0 {
					m.Partitions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Partitions = append(m.Partitions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportLeaderOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportLeaderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportLeaderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replica = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeLeaderOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeLeaderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeLeaderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportConsumerGroupCoordinatorOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportConsumerGroupCoordinatorOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportConsumerGroupCoordinatorOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeConsumerGroupCoordinatorOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeConsumerGroupCoordinatorOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeConsumerGroupCoordinatorOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishActivityOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishActivityOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishActivityOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftIndex", wireType)
			}
			m.RaftIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetStreamReadonlyOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetStreamReadonlyOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetStreamReadonlyOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Partitions = append(m.Partitions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Partitions) == 0 {
					m.Partitions = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Partitions = append(m.Partitions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateConsumerGroupOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateConsumerGroupOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateConsumerGroupOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConsumerGroup == nil {
				m.ConsumerGroup = &ConsumerGroup{}
			}
			if err := m.ConsumerGroup.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinConsumerGroupOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinConsumerGroupOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinConsumerGroupOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveConsumerGroupOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaveConsumerGroupOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaveConsumerGroupOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPolicyOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPolicyOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPolicyOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokePolicyOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokePolicyOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokePolicyOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &Policy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableInt64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableInt64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableInt64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableInt32) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableInt32: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableInt32: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableBool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableBool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableBool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMaxBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetentionMaxBytes == nil {
				m.RetentionMaxBytes = &NullableInt64{}
			}
			if err := m.RetentionMaxBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMaxMessages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetentionMaxMessages == nil {
				m.RetentionMaxMessages = &NullableInt64{}
			}
			if err := m.RetentionMaxMessages.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionMaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetentionMaxAge == nil {
				m.RetentionMaxAge = &NullableInt64{}
			}
			if err := m.RetentionMaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanerInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CleanerInterval == nil {
				m.CleanerInterval = &NullableInt64{}
			}
			if err := m.CleanerInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMaxBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMaxBytes == nil {
				m.SegmentMaxBytes = &NullableInt64{}
			}
			if err := m.SegmentMaxBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentMaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SegmentMaxAge == nil {
				m.SegmentMaxAge = &NullableInt64{}
			}
			if err := m.SegmentMaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactMaxGoroutines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactMaxGoroutines == nil {
				m.CompactMaxGoroutines = &NullableInt32{}
			}
			if err := m.CompactMaxGoroutines.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactEnabled == nil {
				m.CompactEnabled = &NullableBool{}
			}
			if err := m.CompactEnabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPauseTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoPauseTime == nil {
				m.AutoPauseTime = &NullableInt64{}
			}
			if err := m.AutoPauseTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoPauseDisableIfSubscribers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AutoPauseDisableIfSubscribers == nil {
				m.AutoPauseDisableIfSubscribers = &NullableBool{}
			}
			if err := m.AutoPauseDisableIfSubscribers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinIsr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinIsr == nil {
				m.MinIsr = &NullableInt32{}
			}
			if err := m.MinIsr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimisticConcurrencyControl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OptimisticConcurrencyControl == nil {
				m.OptimisticConcurrencyControl = &NullableBool{}
			}
			if err := m.OptimisticConcurrencyControl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encryption == nil {
				m.Encryption = &NullableBool{}
			}
			if err := m.Encryption.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &Partition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &StreamConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			m.CreationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Partition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Partition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Partition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Isr = append(m.Isr, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Readonly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Readonly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Consumer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Consumer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Consumer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumerGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumerGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumerGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Consumer{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftJoinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftJoinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftJoinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftJoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftJoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftJoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Streams = append(m.Streams, &Stream{})
			if err := m.Streams[len(m.Streams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ConsumerGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderEpochOffsetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderEpochOffsetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderEpochOffsetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderEpoch", wireType)
			}
			m.LeaderEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaderEpochOffsetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaderEpochOffsetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaderEpochOffsetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropagatedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropagatedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateStreamOp == nil {
				m.CreateStreamOp = &CreateStreamOp{}
			}
			if err := m.CreateStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShrinkISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShrinkISROp == nil {
				m.ShrinkISROp = &ShrinkISROp{}
			}
			if err := m.ShrinkISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportLeaderOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportLeaderOp == nil {
				m.ReportLeaderOp = &ReportLeaderOp{}
			}
			if err := m.ReportLeaderOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandISROp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpandISROp == nil {
				m.ExpandISROp = &ExpandISROp{}
			}
			if err := m.ExpandISROp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteStreamOp == nil {
				m.DeleteStreamOp = &DeleteStreamOp{}
			}
			if err := m.DeleteStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PauseStreamOp == nil {
				m.PauseStreamOp = &PauseStreamOp{}
			}
			if err := m.PauseStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeStreamOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResumeStreamOp == nil {
				m.ResumeStreamOp = &ResumeStreamOp{}
			}
			if err := m.ResumeStreamOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetStreamReadonlyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetStreamReadonlyOp == nil {
				m.SetStreamReadonlyOp = &SetStreamReadonlyOp{}
			}
			if err := m.SetStreamReadonlyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinConsumerGroupOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinConsumerGroupOp == nil {
				m.JoinConsumerGroupOp = &JoinConsumerGroupOp{}
			}
			if err := m.JoinConsumerGroupOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveConsumerGroupOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeaveConsumerGroupOp == nil {
				m.LeaveConsumerGroupOp = &LeaveConsumerGroupOp{}
			}
			if err := m.LeaveConsumerGroupOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConsumerGroupCoordinatorOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportConsumerGroupCoordinatorOp == nil {
				m.ReportConsumerGroupCoordinatorOp = &ReportConsumerGroupCoordinatorOp{}
			}
			if err := m.ReportConsumerGroupCoordinatorOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPolicyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddPolicyOp == nil {
				m.AddPolicyOp = &AddPolicyOp{}
			}
			if err := m.AddPolicyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokePolicyOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RevokePolicyOp == nil {
				m.RevokePolicyOp = &RevokePolicyOp{}
			}
			if err := m.RevokePolicyOp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropagatedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropagatedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Op(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinConsumerGroupResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JoinConsumerGroupResp == nil {
				m.JoinConsumerGroupResp = &PropagatedResponse_JoinConsumerGroupResponse{}
			}
			if err := m.JoinConsumerGroupResp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropagatedResponse_JoinConsumerGroupResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinConsumerGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinConsumerGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cursor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cursor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cursor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stream", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stream = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CursorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CursorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInternal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInternal
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInternal
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInternal        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInternal          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInternal = fmt.Errorf("proto: unexpected end of group")
)
